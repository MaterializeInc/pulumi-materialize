// Code generated by the Pulumi Terraform Bridge (tfgen) Tool DO NOT EDIT.
// *** WARNING: Do not edit by hand unless you're certain you know what you are doing! ***

package materialize

import (
	"context"
	"reflect"

	"github.com/pkg/errors"
	"github.com/pulumi/pulumi/sdk/v3/go/pulumi"
)

// A cluster replica is the physical resource which maintains dataflow-powered objects.
//
// ## Example Usage
//
// ```go
// package main
//
// import (
//
//	"github.com/pulumi/pulumi-materialize/sdk/go/materialize"
//	"github.com/pulumi/pulumi/sdk/v3/go/pulumi"
//
// )
//
//	func main() {
//		pulumi.Run(func(ctx *pulumi.Context) error {
//			_, err := materialize.NewClusterReplica(ctx, "exampleClusterReplica", &materialize.ClusterReplicaArgs{
//				ClusterName: pulumi.String("cluster"),
//				Size:        pulumi.String("2xsmall"),
//			})
//			if err != nil {
//				return err
//			}
//			return nil
//		})
//	}
//
// ```
//
// ## Import
//
// # Clusters can be imported using the cluster id
//
// ```sh
//
//	$ pulumi import materialize:index/clusterReplica:ClusterReplica example_1_cluster_replica <cluster_replica_id>
//
// ```
type ClusterReplica struct {
	pulumi.CustomResourceState

	// If you want the replica to reside in a specific availability zone.
	AvailabilityZone pulumi.StringPtrOutput `pulumi:"availabilityZone"`
	// The cluster whose resources you want to create an additional computation of.
	ClusterName pulumi.StringOutput `pulumi:"clusterName"`
	// The amount of effort the replica should exert on compacting arrangements during idle periods. This is an unstable option! It may be changed or removed at any time.
	IdleArrangementMergeEffort pulumi.IntPtrOutput `pulumi:"idleArrangementMergeEffort"`
	// Whether to introspect the gathering of the introspection data.
	IntrospectionDebugging pulumi.BoolPtrOutput `pulumi:"introspectionDebugging"`
	// The interval at which to collect introspection data.
	IntrospectionInterval pulumi.StringPtrOutput `pulumi:"introspectionInterval"`
	// The identifier for the replica.
	Name pulumi.StringOutput `pulumi:"name"`
	// The size of the replica.
	Size pulumi.StringOutput `pulumi:"size"`
}

// NewClusterReplica registers a new resource with the given unique name, arguments, and options.
func NewClusterReplica(ctx *pulumi.Context,
	name string, args *ClusterReplicaArgs, opts ...pulumi.ResourceOption) (*ClusterReplica, error) {
	if args == nil {
		return nil, errors.New("missing one or more required arguments")
	}

	if args.ClusterName == nil {
		return nil, errors.New("invalid value for required argument 'ClusterName'")
	}
	if args.Size == nil {
		return nil, errors.New("invalid value for required argument 'Size'")
	}
	opts = pkgResourceDefaultOpts(opts)
	var resource ClusterReplica
	err := ctx.RegisterResource("materialize:index/clusterReplica:ClusterReplica", name, args, &resource, opts...)
	if err != nil {
		return nil, err
	}
	return &resource, nil
}

// GetClusterReplica gets an existing ClusterReplica resource's state with the given name, ID, and optional
// state properties that are used to uniquely qualify the lookup (nil if not required).
func GetClusterReplica(ctx *pulumi.Context,
	name string, id pulumi.IDInput, state *ClusterReplicaState, opts ...pulumi.ResourceOption) (*ClusterReplica, error) {
	var resource ClusterReplica
	err := ctx.ReadResource("materialize:index/clusterReplica:ClusterReplica", name, id, state, &resource, opts...)
	if err != nil {
		return nil, err
	}
	return &resource, nil
}

// Input properties used for looking up and filtering ClusterReplica resources.
type clusterReplicaState struct {
	// If you want the replica to reside in a specific availability zone.
	AvailabilityZone *string `pulumi:"availabilityZone"`
	// The cluster whose resources you want to create an additional computation of.
	ClusterName *string `pulumi:"clusterName"`
	// The amount of effort the replica should exert on compacting arrangements during idle periods. This is an unstable option! It may be changed or removed at any time.
	IdleArrangementMergeEffort *int `pulumi:"idleArrangementMergeEffort"`
	// Whether to introspect the gathering of the introspection data.
	IntrospectionDebugging *bool `pulumi:"introspectionDebugging"`
	// The interval at which to collect introspection data.
	IntrospectionInterval *string `pulumi:"introspectionInterval"`
	// The identifier for the replica.
	Name *string `pulumi:"name"`
	// The size of the replica.
	Size *string `pulumi:"size"`
}

type ClusterReplicaState struct {
	// If you want the replica to reside in a specific availability zone.
	AvailabilityZone pulumi.StringPtrInput
	// The cluster whose resources you want to create an additional computation of.
	ClusterName pulumi.StringPtrInput
	// The amount of effort the replica should exert on compacting arrangements during idle periods. This is an unstable option! It may be changed or removed at any time.
	IdleArrangementMergeEffort pulumi.IntPtrInput
	// Whether to introspect the gathering of the introspection data.
	IntrospectionDebugging pulumi.BoolPtrInput
	// The interval at which to collect introspection data.
	IntrospectionInterval pulumi.StringPtrInput
	// The identifier for the replica.
	Name pulumi.StringPtrInput
	// The size of the replica.
	Size pulumi.StringPtrInput
}

func (ClusterReplicaState) ElementType() reflect.Type {
	return reflect.TypeOf((*clusterReplicaState)(nil)).Elem()
}

type clusterReplicaArgs struct {
	// If you want the replica to reside in a specific availability zone.
	AvailabilityZone *string `pulumi:"availabilityZone"`
	// The cluster whose resources you want to create an additional computation of.
	ClusterName string `pulumi:"clusterName"`
	// The amount of effort the replica should exert on compacting arrangements during idle periods. This is an unstable option! It may be changed or removed at any time.
	IdleArrangementMergeEffort *int `pulumi:"idleArrangementMergeEffort"`
	// Whether to introspect the gathering of the introspection data.
	IntrospectionDebugging *bool `pulumi:"introspectionDebugging"`
	// The interval at which to collect introspection data.
	IntrospectionInterval *string `pulumi:"introspectionInterval"`
	// The identifier for the replica.
	Name *string `pulumi:"name"`
	// The size of the replica.
	Size string `pulumi:"size"`
}

// The set of arguments for constructing a ClusterReplica resource.
type ClusterReplicaArgs struct {
	// If you want the replica to reside in a specific availability zone.
	AvailabilityZone pulumi.StringPtrInput
	// The cluster whose resources you want to create an additional computation of.
	ClusterName pulumi.StringInput
	// The amount of effort the replica should exert on compacting arrangements during idle periods. This is an unstable option! It may be changed or removed at any time.
	IdleArrangementMergeEffort pulumi.IntPtrInput
	// Whether to introspect the gathering of the introspection data.
	IntrospectionDebugging pulumi.BoolPtrInput
	// The interval at which to collect introspection data.
	IntrospectionInterval pulumi.StringPtrInput
	// The identifier for the replica.
	Name pulumi.StringPtrInput
	// The size of the replica.
	Size pulumi.StringInput
}

func (ClusterReplicaArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*clusterReplicaArgs)(nil)).Elem()
}

type ClusterReplicaInput interface {
	pulumi.Input

	ToClusterReplicaOutput() ClusterReplicaOutput
	ToClusterReplicaOutputWithContext(ctx context.Context) ClusterReplicaOutput
}

func (*ClusterReplica) ElementType() reflect.Type {
	return reflect.TypeOf((**ClusterReplica)(nil)).Elem()
}

func (i *ClusterReplica) ToClusterReplicaOutput() ClusterReplicaOutput {
	return i.ToClusterReplicaOutputWithContext(context.Background())
}

func (i *ClusterReplica) ToClusterReplicaOutputWithContext(ctx context.Context) ClusterReplicaOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ClusterReplicaOutput)
}

// ClusterReplicaArrayInput is an input type that accepts ClusterReplicaArray and ClusterReplicaArrayOutput values.
// You can construct a concrete instance of `ClusterReplicaArrayInput` via:
//
//	ClusterReplicaArray{ ClusterReplicaArgs{...} }
type ClusterReplicaArrayInput interface {
	pulumi.Input

	ToClusterReplicaArrayOutput() ClusterReplicaArrayOutput
	ToClusterReplicaArrayOutputWithContext(context.Context) ClusterReplicaArrayOutput
}

type ClusterReplicaArray []ClusterReplicaInput

func (ClusterReplicaArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]*ClusterReplica)(nil)).Elem()
}

func (i ClusterReplicaArray) ToClusterReplicaArrayOutput() ClusterReplicaArrayOutput {
	return i.ToClusterReplicaArrayOutputWithContext(context.Background())
}

func (i ClusterReplicaArray) ToClusterReplicaArrayOutputWithContext(ctx context.Context) ClusterReplicaArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ClusterReplicaArrayOutput)
}

// ClusterReplicaMapInput is an input type that accepts ClusterReplicaMap and ClusterReplicaMapOutput values.
// You can construct a concrete instance of `ClusterReplicaMapInput` via:
//
//	ClusterReplicaMap{ "key": ClusterReplicaArgs{...} }
type ClusterReplicaMapInput interface {
	pulumi.Input

	ToClusterReplicaMapOutput() ClusterReplicaMapOutput
	ToClusterReplicaMapOutputWithContext(context.Context) ClusterReplicaMapOutput
}

type ClusterReplicaMap map[string]ClusterReplicaInput

func (ClusterReplicaMap) ElementType() reflect.Type {
	return reflect.TypeOf((*map[string]*ClusterReplica)(nil)).Elem()
}

func (i ClusterReplicaMap) ToClusterReplicaMapOutput() ClusterReplicaMapOutput {
	return i.ToClusterReplicaMapOutputWithContext(context.Background())
}

func (i ClusterReplicaMap) ToClusterReplicaMapOutputWithContext(ctx context.Context) ClusterReplicaMapOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ClusterReplicaMapOutput)
}

type ClusterReplicaOutput struct{ *pulumi.OutputState }

func (ClusterReplicaOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**ClusterReplica)(nil)).Elem()
}

func (o ClusterReplicaOutput) ToClusterReplicaOutput() ClusterReplicaOutput {
	return o
}

func (o ClusterReplicaOutput) ToClusterReplicaOutputWithContext(ctx context.Context) ClusterReplicaOutput {
	return o
}

// If you want the replica to reside in a specific availability zone.
func (o ClusterReplicaOutput) AvailabilityZone() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *ClusterReplica) pulumi.StringPtrOutput { return v.AvailabilityZone }).(pulumi.StringPtrOutput)
}

// The cluster whose resources you want to create an additional computation of.
func (o ClusterReplicaOutput) ClusterName() pulumi.StringOutput {
	return o.ApplyT(func(v *ClusterReplica) pulumi.StringOutput { return v.ClusterName }).(pulumi.StringOutput)
}

// The amount of effort the replica should exert on compacting arrangements during idle periods. This is an unstable option! It may be changed or removed at any time.
func (o ClusterReplicaOutput) IdleArrangementMergeEffort() pulumi.IntPtrOutput {
	return o.ApplyT(func(v *ClusterReplica) pulumi.IntPtrOutput { return v.IdleArrangementMergeEffort }).(pulumi.IntPtrOutput)
}

// Whether to introspect the gathering of the introspection data.
func (o ClusterReplicaOutput) IntrospectionDebugging() pulumi.BoolPtrOutput {
	return o.ApplyT(func(v *ClusterReplica) pulumi.BoolPtrOutput { return v.IntrospectionDebugging }).(pulumi.BoolPtrOutput)
}

// The interval at which to collect introspection data.
func (o ClusterReplicaOutput) IntrospectionInterval() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *ClusterReplica) pulumi.StringPtrOutput { return v.IntrospectionInterval }).(pulumi.StringPtrOutput)
}

// The identifier for the replica.
func (o ClusterReplicaOutput) Name() pulumi.StringOutput {
	return o.ApplyT(func(v *ClusterReplica) pulumi.StringOutput { return v.Name }).(pulumi.StringOutput)
}

// The size of the replica.
func (o ClusterReplicaOutput) Size() pulumi.StringOutput {
	return o.ApplyT(func(v *ClusterReplica) pulumi.StringOutput { return v.Size }).(pulumi.StringOutput)
}

type ClusterReplicaArrayOutput struct{ *pulumi.OutputState }

func (ClusterReplicaArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]*ClusterReplica)(nil)).Elem()
}

func (o ClusterReplicaArrayOutput) ToClusterReplicaArrayOutput() ClusterReplicaArrayOutput {
	return o
}

func (o ClusterReplicaArrayOutput) ToClusterReplicaArrayOutputWithContext(ctx context.Context) ClusterReplicaArrayOutput {
	return o
}

func (o ClusterReplicaArrayOutput) Index(i pulumi.IntInput) ClusterReplicaOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) *ClusterReplica {
		return vs[0].([]*ClusterReplica)[vs[1].(int)]
	}).(ClusterReplicaOutput)
}

type ClusterReplicaMapOutput struct{ *pulumi.OutputState }

func (ClusterReplicaMapOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*map[string]*ClusterReplica)(nil)).Elem()
}

func (o ClusterReplicaMapOutput) ToClusterReplicaMapOutput() ClusterReplicaMapOutput {
	return o
}

func (o ClusterReplicaMapOutput) ToClusterReplicaMapOutputWithContext(ctx context.Context) ClusterReplicaMapOutput {
	return o
}

func (o ClusterReplicaMapOutput) MapIndex(k pulumi.StringInput) ClusterReplicaOutput {
	return pulumi.All(o, k).ApplyT(func(vs []interface{}) *ClusterReplica {
		return vs[0].(map[string]*ClusterReplica)[vs[1].(string)]
	}).(ClusterReplicaOutput)
}

func init() {
	pulumi.RegisterInputType(reflect.TypeOf((*ClusterReplicaInput)(nil)).Elem(), &ClusterReplica{})
	pulumi.RegisterInputType(reflect.TypeOf((*ClusterReplicaArrayInput)(nil)).Elem(), ClusterReplicaArray{})
	pulumi.RegisterInputType(reflect.TypeOf((*ClusterReplicaMapInput)(nil)).Elem(), ClusterReplicaMap{})
	pulumi.RegisterOutputType(ClusterReplicaOutput{})
	pulumi.RegisterOutputType(ClusterReplicaArrayOutput{})
	pulumi.RegisterOutputType(ClusterReplicaMapOutput{})
}
