// *** WARNING: this file was generated by the Pulumi Terraform Bridge (tfgen) Tool. ***
// *** Do not edit by hand unless you're certain you know what you are doing! ***

import * as pulumi from "@pulumi/pulumi";
import { input as inputs, output as outputs } from "../types";

export interface ConnectionConfluentSchemaRegistryAwsPrivatelink {
    /**
     * The awsPrivatelink database name.
     */
    databaseName?: string;
    /**
     * The awsPrivatelink name.
     */
    name: string;
    /**
     * The awsPrivatelink schema name.
     */
    schemaName?: string;
}

export interface ConnectionConfluentSchemaRegistryPassword {
    /**
     * The password database name.
     */
    databaseName?: string;
    /**
     * The password name.
     */
    name: string;
    /**
     * The password schema name.
     */
    schemaName?: string;
}

export interface ConnectionConfluentSchemaRegistrySshTunnel {
    /**
     * The sshTunnel database name.
     */
    databaseName?: string;
    /**
     * The sshTunnel name.
     */
    name: string;
    /**
     * The sshTunnel schema name.
     */
    schemaName?: string;
}

export interface ConnectionConfluentSchemaRegistrySslCertificate {
    /**
     * The ssl*certificate secret value.
     */
    secret?: outputs.ConnectionConfluentSchemaRegistrySslCertificateSecret;
    /**
     * The sslCertificate text value.
     */
    text?: string;
}

export interface ConnectionConfluentSchemaRegistrySslCertificateAuthority {
    /**
     * The ssl*certificate*authority secret value.
     */
    secret?: outputs.ConnectionConfluentSchemaRegistrySslCertificateAuthoritySecret;
    /**
     * The ssl*certificate*authority text value.
     */
    text?: string;
}

export interface ConnectionConfluentSchemaRegistrySslCertificateAuthoritySecret {
    /**
     * The identifier for the connection database.
     */
    databaseName?: string;
    /**
     * The identifier for the connection.
     */
    name: string;
    /**
     * The identifier for the connection schema.
     */
    schemaName?: string;
}

export interface ConnectionConfluentSchemaRegistrySslCertificateSecret {
    /**
     * The identifier for the connection database.
     */
    databaseName?: string;
    /**
     * The identifier for the connection.
     */
    name: string;
    /**
     * The identifier for the connection schema.
     */
    schemaName?: string;
}

export interface ConnectionConfluentSchemaRegistrySslKey {
    /**
     * The sslKey database name.
     */
    databaseName?: string;
    /**
     * The sslKey name.
     */
    name: string;
    /**
     * The sslKey schema name.
     */
    schemaName?: string;
}

export interface ConnectionConfluentSchemaRegistryUsername {
    /**
     * The username secret value.
     */
    secret?: outputs.ConnectionConfluentSchemaRegistryUsernameSecret;
    /**
     * The username text value.
     */
    text?: string;
}

export interface ConnectionConfluentSchemaRegistryUsernameSecret {
    /**
     * The identifier for the connection database.
     */
    databaseName?: string;
    /**
     * The identifier for the connection.
     */
    name: string;
    /**
     * The identifier for the connection schema.
     */
    schemaName?: string;
}

export interface ConnectionKafkaKafkaBroker {
    /**
     * The availability zone of the Kafka broker.
     */
    availabilityZone?: string;
    /**
     * The Kafka broker, in the form of `host:port`.
     */
    broker: string;
    /**
     * The AWS PrivateLink connection name in Materialize.
     */
    privatelinkConnection?: outputs.ConnectionKafkaKafkaBrokerPrivatelinkConnection;
    /**
     * The port of the target group associated with the Kafka broker.
     */
    targetGroupPort?: number;
}

export interface ConnectionKafkaKafkaBrokerPrivatelinkConnection {
    /**
     * The identifier for the connection database.
     */
    databaseName?: string;
    /**
     * The identifier for the connection.
     */
    name: string;
    /**
     * The identifier for the connection schema.
     */
    schemaName?: string;
}

export interface ConnectionKafkaSaslPassword {
    /**
     * The saslPassword database name.
     */
    databaseName?: string;
    /**
     * The saslPassword name.
     */
    name: string;
    /**
     * The saslPassword schema name.
     */
    schemaName?: string;
}

export interface ConnectionKafkaSaslUsername {
    /**
     * The sasl*username secret value.
     */
    secret?: outputs.ConnectionKafkaSaslUsernameSecret;
    /**
     * The saslUsername text value.
     */
    text?: string;
}

export interface ConnectionKafkaSaslUsernameSecret {
    /**
     * The identifier for the connection database.
     */
    databaseName?: string;
    /**
     * The identifier for the connection.
     */
    name: string;
    /**
     * The identifier for the connection schema.
     */
    schemaName?: string;
}

export interface ConnectionKafkaSshTunnel {
    /**
     * The sshTunnel database name.
     */
    databaseName?: string;
    /**
     * The sshTunnel name.
     */
    name: string;
    /**
     * The sshTunnel schema name.
     */
    schemaName?: string;
}

export interface ConnectionKafkaSslCertificate {
    /**
     * The ssl*certificate secret value.
     */
    secret?: outputs.ConnectionKafkaSslCertificateSecret;
    /**
     * The sslCertificate text value.
     */
    text?: string;
}

export interface ConnectionKafkaSslCertificateAuthority {
    /**
     * The ssl*certificate*authority secret value.
     */
    secret?: outputs.ConnectionKafkaSslCertificateAuthoritySecret;
    /**
     * The ssl*certificate*authority text value.
     */
    text?: string;
}

export interface ConnectionKafkaSslCertificateAuthoritySecret {
    /**
     * The identifier for the connection database.
     */
    databaseName?: string;
    /**
     * The identifier for the connection.
     */
    name: string;
    /**
     * The identifier for the connection schema.
     */
    schemaName?: string;
}

export interface ConnectionKafkaSslCertificateSecret {
    /**
     * The identifier for the connection database.
     */
    databaseName?: string;
    /**
     * The identifier for the connection.
     */
    name: string;
    /**
     * The identifier for the connection schema.
     */
    schemaName?: string;
}

export interface ConnectionKafkaSslKey {
    /**
     * The sslKey database name.
     */
    databaseName?: string;
    /**
     * The sslKey name.
     */
    name: string;
    /**
     * The sslKey schema name.
     */
    schemaName?: string;
}

export interface ConnectionPostgresAwsPrivatelink {
    /**
     * The awsPrivatelink database name.
     */
    databaseName?: string;
    /**
     * The awsPrivatelink name.
     */
    name: string;
    /**
     * The awsPrivatelink schema name.
     */
    schemaName?: string;
}

export interface ConnectionPostgresPassword {
    /**
     * The password database name.
     */
    databaseName?: string;
    /**
     * The password name.
     */
    name: string;
    /**
     * The password schema name.
     */
    schemaName?: string;
}

export interface ConnectionPostgresSshTunnel {
    /**
     * The sshTunnel database name.
     */
    databaseName?: string;
    /**
     * The sshTunnel name.
     */
    name: string;
    /**
     * The sshTunnel schema name.
     */
    schemaName?: string;
}

export interface ConnectionPostgresSslCertificate {
    /**
     * The ssl*certificate secret value.
     */
    secret?: outputs.ConnectionPostgresSslCertificateSecret;
    /**
     * The sslCertificate text value.
     */
    text?: string;
}

export interface ConnectionPostgresSslCertificateAuthority {
    /**
     * The ssl*certificate*authority secret value.
     */
    secret?: outputs.ConnectionPostgresSslCertificateAuthoritySecret;
    /**
     * The ssl*certificate*authority text value.
     */
    text?: string;
}

export interface ConnectionPostgresSslCertificateAuthoritySecret {
    /**
     * The identifier for the connection database.
     */
    databaseName?: string;
    /**
     * The identifier for the connection.
     */
    name: string;
    /**
     * The identifier for the connection schema.
     */
    schemaName?: string;
}

export interface ConnectionPostgresSslCertificateSecret {
    /**
     * The identifier for the connection database.
     */
    databaseName?: string;
    /**
     * The identifier for the connection.
     */
    name: string;
    /**
     * The identifier for the connection schema.
     */
    schemaName?: string;
}

export interface ConnectionPostgresSslKey {
    /**
     * The sslKey database name.
     */
    databaseName?: string;
    /**
     * The sslKey name.
     */
    name: string;
    /**
     * The sslKey schema name.
     */
    schemaName?: string;
}

export interface ConnectionPostgresUser {
    /**
     * The user secret value.
     */
    secret?: outputs.ConnectionPostgresUserSecret;
    /**
     * The user text value.
     */
    text?: string;
}

export interface ConnectionPostgresUserSecret {
    /**
     * The identifier for the connection database.
     */
    databaseName?: string;
    /**
     * The identifier for the connection.
     */
    name: string;
    /**
     * The identifier for the connection schema.
     */
    schemaName?: string;
}

export interface GetClusterReplicasClusterReplica {
    availabilityZone: string;
    cluster: string;
    /**
     * The ID of this resource.
     */
    id: string;
    name: string;
    size: string;
}

export interface GetClustersCluster {
    /**
     * The ID of this resource.
     */
    id: string;
    name: string;
}

export interface GetConnectionsConnection {
    /**
     * Limit connections to a specific database
     */
    databaseName: string;
    /**
     * The ID of this resource.
     */
    id: string;
    name: string;
    /**
     * Limit connections to a specific schema within a specific database
     */
    schemaName: string;
    type: string;
}

export interface GetDatabasesDatabase {
    /**
     * The ID of this resource.
     */
    id: string;
    name: string;
}

export interface GetIndexesIndex {
    /**
     * The ID of this resource.
     */
    id: string;
    name: string;
    objDatabase: string;
    objName: string;
    objSchema: string;
}

export interface GetMaterializedViewsMaterializedView {
    /**
     * Limit materialized views to a specific database
     */
    databaseName: string;
    /**
     * The ID of this resource.
     */
    id: string;
    name: string;
    /**
     * Limit materialized views to a specific schema within a specific database
     */
    schemaName: string;
}

export interface GetSchemasSchema {
    /**
     * Limit schemas to a specific database
     */
    databaseName: string;
    /**
     * The ID of this resource.
     */
    id: string;
    name: string;
}

export interface GetSecretsSecret {
    /**
     * Limit secrets to a specific database
     */
    databaseName: string;
    /**
     * The ID of this resource.
     */
    id: string;
    name: string;
    /**
     * Limit secrets to a specific schema within a specific database
     */
    schemaName: string;
}

export interface GetSinksSink {
    clusterName: string;
    connectionName: string;
    /**
     * Limit sinks to a specific database
     */
    databaseName: string;
    envelopeType: string;
    /**
     * The ID of this resource.
     */
    id: string;
    name: string;
    /**
     * Limit sinks to a specific schema within a specific database
     */
    schemaName: string;
    size: string;
    type: string;
}

export interface GetSourcesSource {
    clusterName: string;
    connectionName: string;
    /**
     * Limit sources to a specific database
     */
    databaseName: string;
    envelopeType: string;
    /**
     * The ID of this resource.
     */
    id: string;
    name: string;
    /**
     * Limit sources to a specific schema within a specific database
     */
    schemaName: string;
    size: string;
    type: string;
}

export interface GetTablesTable {
    /**
     * Limit tables to a specific database
     */
    databaseName: string;
    /**
     * The ID of this resource.
     */
    id: string;
    name: string;
    /**
     * Limit tables to a specific schema within a specific database
     */
    schemaName: string;
}

export interface GetViewsView {
    /**
     * Limit views to a specific database
     */
    databaseName: string;
    /**
     * The ID of this resource.
     */
    id: string;
    name: string;
    /**
     * Limit views to a specific schema within a specific database
     */
    schemaName: string;
}

export interface IndexColExpr {
    /**
     * The name of the option you want to set.
     */
    field: string;
    /**
     * The value for the option.
     */
    val?: string;
}

export interface IndexObjName {
    /**
     * The objName database name.
     */
    databaseName?: string;
    /**
     * The objName name.
     */
    name: string;
    /**
     * The objName schema name.
     */
    schemaName?: string;
}

export interface SinkKafkaEnvelope {
    /**
     * The generated schemas have a Debezium-style diff envelope to capture changes in the input view or source.
     */
    debezium?: boolean;
    /**
     * The sink emits data with upsert semantics: updates and inserts for the given key are expressed as a value, and deletes are expressed as a null value payload in Kafka.
     */
    upsert?: boolean;
}

export interface SinkKafkaFormat {
    /**
     * Avro format.
     */
    avro?: outputs.SinkKafkaFormatAvro;
    /**
     * JSON format.
     */
    json?: boolean;
}

export interface SinkKafkaFormatAvro {
    avroKeyFullname?: string;
    avroValueFullname?: string;
    schemaRegistryConnection: outputs.SinkKafkaFormatAvroSchemaRegistryConnection;
}

export interface SinkKafkaFormatAvroSchemaRegistryConnection {
    /**
     * The identifier for the sink database.
     */
    databaseName?: string;
    /**
     * The identifier for the sink.
     */
    name: string;
    /**
     * The identifier for the sink schema.
     */
    schemaName?: string;
}

export interface SinkKafkaFrom {
    /**
     * The from database name.
     */
    databaseName?: string;
    /**
     * The from name.
     */
    name: string;
    /**
     * The from schema name.
     */
    schemaName?: string;
}

export interface SinkKafkaKafkaConnection {
    /**
     * The kafkaConnection database name.
     */
    databaseName?: string;
    /**
     * The kafkaConnection name.
     */
    name: string;
    /**
     * The kafkaConnection schema name.
     */
    schemaName?: string;
}

export interface SourceKafkaEnvelope {
    /**
     * Use the Debezium envelope, which uses a diff envelope to handle CRUD operations.
     */
    debezium?: boolean;
    /**
     * Use an append-only envelope. This means that records will only be appended and cannot be updated or deleted.
     */
    none?: boolean;
    /**
     * Use the upsert envelope, which uses message keys to handle CRUD operations.
     */
    upsert?: boolean;
}

export interface SourceKafkaFormat {
    /**
     * Avro format.
     */
    avro?: outputs.SourceKafkaFormatAvro;
    /**
     * CSV format.
     */
    csvs?: outputs.SourceKafkaFormatCsv[];
    /**
     * JSON format.
     */
    json?: boolean;
    /**
     * Protobuf format.
     */
    protobuf?: outputs.SourceKafkaFormatProtobuf;
    /**
     * Text format.
     */
    text?: boolean;
}

export interface SourceKafkaFormatAvro {
    keyStrategy?: string;
    schemaRegistryConnection: outputs.SourceKafkaFormatAvroSchemaRegistryConnection;
    valueStrategy?: string;
}

export interface SourceKafkaFormatAvroSchemaRegistryConnection {
    /**
     * The identifier for the source database.
     */
    databaseName?: string;
    /**
     * The identifier for the source.
     */
    name: string;
    /**
     * The identifier for the source schema.
     */
    schemaName?: string;
}

export interface SourceKafkaFormatCsv {
    column?: number;
    delimitedBy?: string;
    headers?: string[];
}

export interface SourceKafkaFormatProtobuf {
    message: string;
    schemaRegistryConnection: outputs.SourceKafkaFormatProtobufSchemaRegistryConnection;
}

export interface SourceKafkaFormatProtobufSchemaRegistryConnection {
    /**
     * The identifier for the source database.
     */
    databaseName?: string;
    /**
     * The identifier for the source.
     */
    name: string;
    /**
     * The identifier for the source schema.
     */
    schemaName?: string;
}

export interface SourceKafkaKafkaConnection {
    /**
     * The kafkaConnection database name.
     */
    databaseName?: string;
    /**
     * The kafkaConnection name.
     */
    name: string;
    /**
     * The kafkaConnection schema name.
     */
    schemaName?: string;
}

export interface SourceKafkaKeyFormat {
    /**
     * Avro format.
     */
    avro?: outputs.SourceKafkaKeyFormatAvro;
    /**
     * CSV format.
     */
    csvs?: outputs.SourceKafkaKeyFormatCsv[];
    /**
     * JSON format.
     */
    json?: boolean;
    /**
     * Protobuf format.
     */
    protobuf?: outputs.SourceKafkaKeyFormatProtobuf;
    /**
     * Text format.
     */
    text?: boolean;
}

export interface SourceKafkaKeyFormatAvro {
    keyStrategy?: string;
    schemaRegistryConnection: outputs.SourceKafkaKeyFormatAvroSchemaRegistryConnection;
    valueStrategy?: string;
}

export interface SourceKafkaKeyFormatAvroSchemaRegistryConnection {
    /**
     * The identifier for the source database.
     */
    databaseName?: string;
    /**
     * The identifier for the source.
     */
    name: string;
    /**
     * The identifier for the source schema.
     */
    schemaName?: string;
}

export interface SourceKafkaKeyFormatCsv {
    column?: number;
    delimitedBy?: string;
    headers?: string[];
}

export interface SourceKafkaKeyFormatProtobuf {
    message: string;
    schemaRegistryConnection: outputs.SourceKafkaKeyFormatProtobufSchemaRegistryConnection;
}

export interface SourceKafkaKeyFormatProtobufSchemaRegistryConnection {
    /**
     * The identifier for the source database.
     */
    databaseName?: string;
    /**
     * The identifier for the source.
     */
    name: string;
    /**
     * The identifier for the source schema.
     */
    schemaName?: string;
}

export interface SourceKafkaValueFormat {
    /**
     * Avro format.
     */
    avro?: outputs.SourceKafkaValueFormatAvro;
    /**
     * CSV format.
     */
    csvs?: outputs.SourceKafkaValueFormatCsv[];
    /**
     * JSON format.
     */
    json?: boolean;
    /**
     * Protobuf format.
     */
    protobuf?: outputs.SourceKafkaValueFormatProtobuf;
    /**
     * Text format.
     */
    text?: boolean;
}

export interface SourceKafkaValueFormatAvro {
    keyStrategy?: string;
    schemaRegistryConnection: outputs.SourceKafkaValueFormatAvroSchemaRegistryConnection;
    valueStrategy?: string;
}

export interface SourceKafkaValueFormatAvroSchemaRegistryConnection {
    /**
     * The identifier for the source database.
     */
    databaseName?: string;
    /**
     * The identifier for the source.
     */
    name: string;
    /**
     * The identifier for the source schema.
     */
    schemaName?: string;
}

export interface SourceKafkaValueFormatCsv {
    column?: number;
    delimitedBy?: string;
    headers?: string[];
}

export interface SourceKafkaValueFormatProtobuf {
    message: string;
    schemaRegistryConnection: outputs.SourceKafkaValueFormatProtobufSchemaRegistryConnection;
}

export interface SourceKafkaValueFormatProtobufSchemaRegistryConnection {
    /**
     * The identifier for the source database.
     */
    databaseName?: string;
    /**
     * The identifier for the source.
     */
    name: string;
    /**
     * The identifier for the source schema.
     */
    schemaName?: string;
}

export interface SourceLoadgenAuctionOption {
    /**
     * The scale factor for the generator. Defaults to 0.01 (~ 10MB).
     */
    scaleFactor?: number;
    /**
     * Creates subsources for specific tables.
     */
    tables?: outputs.SourceLoadgenAuctionOptionTable[];
    /**
     * The interval at which the next datum should be emitted. Defaults to one second.
     */
    tickInterval?: string;
}

export interface SourceLoadgenAuctionOptionTable {
    alias?: string;
    /**
     * The identifier for the source.
     */
    name: string;
}

export interface SourceLoadgenCounterOption {
    /**
     * Causes the generator to delete old values to keep the collection at most a given size. Defaults to unlimited.
     */
    maxCardinality?: number;
    /**
     * The scale factor for the generator. Defaults to 0.01 (~ 10MB).
     */
    scaleFactor?: number;
    /**
     * The interval at which the next datum should be emitted. Defaults to one second.
     */
    tickInterval?: string;
}

export interface SourceLoadgenTpchOption {
    /**
     * The scale factor for the generator. Defaults to 0.01 (~ 10MB).
     */
    scaleFactor?: number;
    /**
     * Creates subsources for specific tables.
     */
    tables?: outputs.SourceLoadgenTpchOptionTable[];
    /**
     * The interval at which the next datum should be emitted. Defaults to one second.
     */
    tickInterval?: string;
}

export interface SourceLoadgenTpchOptionTable {
    alias?: string;
    /**
     * The identifier for the source.
     */
    name: string;
}

export interface SourcePostgresPostgresConnection {
    /**
     * The posgresConnection database name.
     */
    databaseName?: string;
    /**
     * The posgresConnection name.
     */
    name: string;
    /**
     * The posgresConnection schema name.
     */
    schemaName?: string;
}

export interface SourcePostgresTable {
    /**
     * The alias of the table.
     */
    alias?: string;
    /**
     * The name of the table.
     */
    name: string;
}

export interface TableColumn {
    /**
     * The name of the column to be created in the table.
     */
    name: string;
    /**
     * Do not allow the column to contain NULL values. Columns without this constraint can contain NULL values.
     */
    nullable?: boolean;
    /**
     * The data type of the column indicated by name.
     */
    type: string;
}

