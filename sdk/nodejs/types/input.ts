// *** WARNING: this file was generated by the Pulumi Terraform Bridge (tfgen) Tool. ***
// *** Do not edit by hand unless you're certain you know what you are doing! ***

import * as pulumi from "@pulumi/pulumi";
import { input as inputs, output as outputs } from "../types";

export interface ConnectionConfluentSchemaRegistryAwsPrivatelink {
    /**
     * The awsPrivatelink database name.
     */
    databaseName?: pulumi.Input<string>;
    /**
     * The awsPrivatelink name.
     */
    name: pulumi.Input<string>;
    /**
     * The awsPrivatelink schema name.
     */
    schemaName?: pulumi.Input<string>;
}

export interface ConnectionConfluentSchemaRegistryPassword {
    /**
     * The password database name.
     */
    databaseName?: pulumi.Input<string>;
    /**
     * The password name.
     */
    name: pulumi.Input<string>;
    /**
     * The password schema name.
     */
    schemaName?: pulumi.Input<string>;
}

export interface ConnectionConfluentSchemaRegistrySshTunnel {
    /**
     * The sshTunnel database name.
     */
    databaseName?: pulumi.Input<string>;
    /**
     * The sshTunnel name.
     */
    name: pulumi.Input<string>;
    /**
     * The sshTunnel schema name.
     */
    schemaName?: pulumi.Input<string>;
}

export interface ConnectionConfluentSchemaRegistrySslCertificate {
    /**
     * The ssl*certificate secret value.
     */
    secret?: pulumi.Input<inputs.ConnectionConfluentSchemaRegistrySslCertificateSecret>;
    /**
     * The sslCertificate text value.
     */
    text?: pulumi.Input<string>;
}

export interface ConnectionConfluentSchemaRegistrySslCertificateAuthority {
    /**
     * The ssl*certificate*authority secret value.
     */
    secret?: pulumi.Input<inputs.ConnectionConfluentSchemaRegistrySslCertificateAuthoritySecret>;
    /**
     * The ssl*certificate*authority text value.
     */
    text?: pulumi.Input<string>;
}

export interface ConnectionConfluentSchemaRegistrySslCertificateAuthoritySecret {
    /**
     * The identifier for the connection database.
     */
    databaseName?: pulumi.Input<string>;
    /**
     * The identifier for the connection.
     */
    name: pulumi.Input<string>;
    /**
     * The identifier for the connection schema.
     */
    schemaName?: pulumi.Input<string>;
}

export interface ConnectionConfluentSchemaRegistrySslCertificateSecret {
    /**
     * The identifier for the connection database.
     */
    databaseName?: pulumi.Input<string>;
    /**
     * The identifier for the connection.
     */
    name: pulumi.Input<string>;
    /**
     * The identifier for the connection schema.
     */
    schemaName?: pulumi.Input<string>;
}

export interface ConnectionConfluentSchemaRegistrySslKey {
    /**
     * The sslKey database name.
     */
    databaseName?: pulumi.Input<string>;
    /**
     * The sslKey name.
     */
    name: pulumi.Input<string>;
    /**
     * The sslKey schema name.
     */
    schemaName?: pulumi.Input<string>;
}

export interface ConnectionConfluentSchemaRegistryUsername {
    /**
     * The username secret value.
     */
    secret?: pulumi.Input<inputs.ConnectionConfluentSchemaRegistryUsernameSecret>;
    /**
     * The username text value.
     */
    text?: pulumi.Input<string>;
}

export interface ConnectionConfluentSchemaRegistryUsernameSecret {
    /**
     * The identifier for the connection database.
     */
    databaseName?: pulumi.Input<string>;
    /**
     * The identifier for the connection.
     */
    name: pulumi.Input<string>;
    /**
     * The identifier for the connection schema.
     */
    schemaName?: pulumi.Input<string>;
}

export interface ConnectionKafkaKafkaBroker {
    /**
     * The availability zone of the Kafka broker.
     */
    availabilityZone?: pulumi.Input<string>;
    /**
     * The Kafka broker, in the form of `host:port`.
     */
    broker: pulumi.Input<string>;
    /**
     * The AWS PrivateLink connection name in Materialize.
     */
    privatelinkConnection?: pulumi.Input<inputs.ConnectionKafkaKafkaBrokerPrivatelinkConnection>;
    /**
     * The port of the target group associated with the Kafka broker.
     */
    targetGroupPort?: pulumi.Input<number>;
}

export interface ConnectionKafkaKafkaBrokerPrivatelinkConnection {
    /**
     * The identifier for the connection database.
     */
    databaseName?: pulumi.Input<string>;
    /**
     * The identifier for the connection.
     */
    name: pulumi.Input<string>;
    /**
     * The identifier for the connection schema.
     */
    schemaName?: pulumi.Input<string>;
}

export interface ConnectionKafkaSaslPassword {
    /**
     * The saslPassword database name.
     */
    databaseName?: pulumi.Input<string>;
    /**
     * The saslPassword name.
     */
    name: pulumi.Input<string>;
    /**
     * The saslPassword schema name.
     */
    schemaName?: pulumi.Input<string>;
}

export interface ConnectionKafkaSaslUsername {
    /**
     * The sasl*username secret value.
     */
    secret?: pulumi.Input<inputs.ConnectionKafkaSaslUsernameSecret>;
    /**
     * The saslUsername text value.
     */
    text?: pulumi.Input<string>;
}

export interface ConnectionKafkaSaslUsernameSecret {
    /**
     * The identifier for the connection database.
     */
    databaseName?: pulumi.Input<string>;
    /**
     * The identifier for the connection.
     */
    name: pulumi.Input<string>;
    /**
     * The identifier for the connection schema.
     */
    schemaName?: pulumi.Input<string>;
}

export interface ConnectionKafkaSshTunnel {
    /**
     * The sshTunnel database name.
     */
    databaseName?: pulumi.Input<string>;
    /**
     * The sshTunnel name.
     */
    name: pulumi.Input<string>;
    /**
     * The sshTunnel schema name.
     */
    schemaName?: pulumi.Input<string>;
}

export interface ConnectionKafkaSslCertificate {
    /**
     * The ssl*certificate secret value.
     */
    secret?: pulumi.Input<inputs.ConnectionKafkaSslCertificateSecret>;
    /**
     * The sslCertificate text value.
     */
    text?: pulumi.Input<string>;
}

export interface ConnectionKafkaSslCertificateAuthority {
    /**
     * The ssl*certificate*authority secret value.
     */
    secret?: pulumi.Input<inputs.ConnectionKafkaSslCertificateAuthoritySecret>;
    /**
     * The ssl*certificate*authority text value.
     */
    text?: pulumi.Input<string>;
}

export interface ConnectionKafkaSslCertificateAuthoritySecret {
    /**
     * The identifier for the connection database.
     */
    databaseName?: pulumi.Input<string>;
    /**
     * The identifier for the connection.
     */
    name: pulumi.Input<string>;
    /**
     * The identifier for the connection schema.
     */
    schemaName?: pulumi.Input<string>;
}

export interface ConnectionKafkaSslCertificateSecret {
    /**
     * The identifier for the connection database.
     */
    databaseName?: pulumi.Input<string>;
    /**
     * The identifier for the connection.
     */
    name: pulumi.Input<string>;
    /**
     * The identifier for the connection schema.
     */
    schemaName?: pulumi.Input<string>;
}

export interface ConnectionKafkaSslKey {
    /**
     * The sslKey database name.
     */
    databaseName?: pulumi.Input<string>;
    /**
     * The sslKey name.
     */
    name: pulumi.Input<string>;
    /**
     * The sslKey schema name.
     */
    schemaName?: pulumi.Input<string>;
}

export interface ConnectionPostgresAwsPrivatelink {
    /**
     * The awsPrivatelink database name.
     */
    databaseName?: pulumi.Input<string>;
    /**
     * The awsPrivatelink name.
     */
    name: pulumi.Input<string>;
    /**
     * The awsPrivatelink schema name.
     */
    schemaName?: pulumi.Input<string>;
}

export interface ConnectionPostgresPassword {
    /**
     * The password database name.
     */
    databaseName?: pulumi.Input<string>;
    /**
     * The password name.
     */
    name: pulumi.Input<string>;
    /**
     * The password schema name.
     */
    schemaName?: pulumi.Input<string>;
}

export interface ConnectionPostgresSshTunnel {
    /**
     * The sshTunnel database name.
     */
    databaseName?: pulumi.Input<string>;
    /**
     * The sshTunnel name.
     */
    name: pulumi.Input<string>;
    /**
     * The sshTunnel schema name.
     */
    schemaName?: pulumi.Input<string>;
}

export interface ConnectionPostgresSslCertificate {
    /**
     * The ssl*certificate secret value.
     */
    secret?: pulumi.Input<inputs.ConnectionPostgresSslCertificateSecret>;
    /**
     * The sslCertificate text value.
     */
    text?: pulumi.Input<string>;
}

export interface ConnectionPostgresSslCertificateAuthority {
    /**
     * The ssl*certificate*authority secret value.
     */
    secret?: pulumi.Input<inputs.ConnectionPostgresSslCertificateAuthoritySecret>;
    /**
     * The ssl*certificate*authority text value.
     */
    text?: pulumi.Input<string>;
}

export interface ConnectionPostgresSslCertificateAuthoritySecret {
    /**
     * The identifier for the connection database.
     */
    databaseName?: pulumi.Input<string>;
    /**
     * The identifier for the connection.
     */
    name: pulumi.Input<string>;
    /**
     * The identifier for the connection schema.
     */
    schemaName?: pulumi.Input<string>;
}

export interface ConnectionPostgresSslCertificateSecret {
    /**
     * The identifier for the connection database.
     */
    databaseName?: pulumi.Input<string>;
    /**
     * The identifier for the connection.
     */
    name: pulumi.Input<string>;
    /**
     * The identifier for the connection schema.
     */
    schemaName?: pulumi.Input<string>;
}

export interface ConnectionPostgresSslKey {
    /**
     * The sslKey database name.
     */
    databaseName?: pulumi.Input<string>;
    /**
     * The sslKey name.
     */
    name: pulumi.Input<string>;
    /**
     * The sslKey schema name.
     */
    schemaName?: pulumi.Input<string>;
}

export interface ConnectionPostgresUser {
    /**
     * The user secret value.
     */
    secret?: pulumi.Input<inputs.ConnectionPostgresUserSecret>;
    /**
     * The user text value.
     */
    text?: pulumi.Input<string>;
}

export interface ConnectionPostgresUserSecret {
    /**
     * The identifier for the connection database.
     */
    databaseName?: pulumi.Input<string>;
    /**
     * The identifier for the connection.
     */
    name: pulumi.Input<string>;
    /**
     * The identifier for the connection schema.
     */
    schemaName?: pulumi.Input<string>;
}

export interface IndexColExpr {
    /**
     * The name of the option you want to set.
     */
    field: pulumi.Input<string>;
    /**
     * The value for the option.
     */
    val?: pulumi.Input<string>;
}

export interface IndexObjName {
    /**
     * The objName database name.
     */
    databaseName?: pulumi.Input<string>;
    /**
     * The objName name.
     */
    name: pulumi.Input<string>;
    /**
     * The objName schema name.
     */
    schemaName?: pulumi.Input<string>;
}

export interface SinkKafkaEnvelope {
    /**
     * The generated schemas have a Debezium-style diff envelope to capture changes in the input view or source.
     */
    debezium?: pulumi.Input<boolean>;
    /**
     * The sink emits data with upsert semantics: updates and inserts for the given key are expressed as a value, and deletes are expressed as a null value payload in Kafka.
     */
    upsert?: pulumi.Input<boolean>;
}

export interface SinkKafkaFormat {
    /**
     * Avro format.
     */
    avro?: pulumi.Input<inputs.SinkKafkaFormatAvro>;
    /**
     * JSON format.
     */
    json?: pulumi.Input<boolean>;
}

export interface SinkKafkaFormatAvro {
    avroKeyFullname?: pulumi.Input<string>;
    avroValueFullname?: pulumi.Input<string>;
    schemaRegistryConnection: pulumi.Input<inputs.SinkKafkaFormatAvroSchemaRegistryConnection>;
}

export interface SinkKafkaFormatAvroSchemaRegistryConnection {
    /**
     * The identifier for the sink database.
     */
    databaseName?: pulumi.Input<string>;
    /**
     * The identifier for the sink.
     */
    name: pulumi.Input<string>;
    /**
     * The identifier for the sink schema.
     */
    schemaName?: pulumi.Input<string>;
}

export interface SinkKafkaFrom {
    /**
     * The from database name.
     */
    databaseName?: pulumi.Input<string>;
    /**
     * The from name.
     */
    name: pulumi.Input<string>;
    /**
     * The from schema name.
     */
    schemaName?: pulumi.Input<string>;
}

export interface SinkKafkaKafkaConnection {
    /**
     * The kafkaConnection database name.
     */
    databaseName?: pulumi.Input<string>;
    /**
     * The kafkaConnection name.
     */
    name: pulumi.Input<string>;
    /**
     * The kafkaConnection schema name.
     */
    schemaName?: pulumi.Input<string>;
}

export interface SourceKafkaEnvelope {
    /**
     * Use the Debezium envelope, which uses a diff envelope to handle CRUD operations.
     */
    debezium?: pulumi.Input<boolean>;
    /**
     * Use an append-only envelope. This means that records will only be appended and cannot be updated or deleted.
     */
    none?: pulumi.Input<boolean>;
    /**
     * Use the upsert envelope, which uses message keys to handle CRUD operations.
     */
    upsert?: pulumi.Input<boolean>;
}

export interface SourceKafkaFormat {
    /**
     * Avro format.
     */
    avro?: pulumi.Input<inputs.SourceKafkaFormatAvro>;
    /**
     * CSV format.
     */
    csvs?: pulumi.Input<pulumi.Input<inputs.SourceKafkaFormatCsv>[]>;
    /**
     * JSON format.
     */
    json?: pulumi.Input<boolean>;
    /**
     * Protobuf format.
     */
    protobuf?: pulumi.Input<inputs.SourceKafkaFormatProtobuf>;
    /**
     * Text format.
     */
    text?: pulumi.Input<boolean>;
}

export interface SourceKafkaFormatAvro {
    keyStrategy?: pulumi.Input<string>;
    schemaRegistryConnection: pulumi.Input<inputs.SourceKafkaFormatAvroSchemaRegistryConnection>;
    valueStrategy?: pulumi.Input<string>;
}

export interface SourceKafkaFormatAvroSchemaRegistryConnection {
    /**
     * The identifier for the source database.
     */
    databaseName?: pulumi.Input<string>;
    /**
     * The identifier for the source.
     */
    name: pulumi.Input<string>;
    /**
     * The identifier for the source schema.
     */
    schemaName?: pulumi.Input<string>;
}

export interface SourceKafkaFormatCsv {
    column?: pulumi.Input<number>;
    delimitedBy?: pulumi.Input<string>;
    headers?: pulumi.Input<pulumi.Input<string>[]>;
}

export interface SourceKafkaFormatProtobuf {
    message: pulumi.Input<string>;
    schemaRegistryConnection: pulumi.Input<inputs.SourceKafkaFormatProtobufSchemaRegistryConnection>;
}

export interface SourceKafkaFormatProtobufSchemaRegistryConnection {
    /**
     * The identifier for the source database.
     */
    databaseName?: pulumi.Input<string>;
    /**
     * The identifier for the source.
     */
    name: pulumi.Input<string>;
    /**
     * The identifier for the source schema.
     */
    schemaName?: pulumi.Input<string>;
}

export interface SourceKafkaKafkaConnection {
    /**
     * The kafkaConnection database name.
     */
    databaseName?: pulumi.Input<string>;
    /**
     * The kafkaConnection name.
     */
    name: pulumi.Input<string>;
    /**
     * The kafkaConnection schema name.
     */
    schemaName?: pulumi.Input<string>;
}

export interface SourceKafkaKeyFormat {
    /**
     * Avro format.
     */
    avro?: pulumi.Input<inputs.SourceKafkaKeyFormatAvro>;
    /**
     * CSV format.
     */
    csvs?: pulumi.Input<pulumi.Input<inputs.SourceKafkaKeyFormatCsv>[]>;
    /**
     * JSON format.
     */
    json?: pulumi.Input<boolean>;
    /**
     * Protobuf format.
     */
    protobuf?: pulumi.Input<inputs.SourceKafkaKeyFormatProtobuf>;
    /**
     * Text format.
     */
    text?: pulumi.Input<boolean>;
}

export interface SourceKafkaKeyFormatAvro {
    keyStrategy?: pulumi.Input<string>;
    schemaRegistryConnection: pulumi.Input<inputs.SourceKafkaKeyFormatAvroSchemaRegistryConnection>;
    valueStrategy?: pulumi.Input<string>;
}

export interface SourceKafkaKeyFormatAvroSchemaRegistryConnection {
    /**
     * The identifier for the source database.
     */
    databaseName?: pulumi.Input<string>;
    /**
     * The identifier for the source.
     */
    name: pulumi.Input<string>;
    /**
     * The identifier for the source schema.
     */
    schemaName?: pulumi.Input<string>;
}

export interface SourceKafkaKeyFormatCsv {
    column?: pulumi.Input<number>;
    delimitedBy?: pulumi.Input<string>;
    headers?: pulumi.Input<pulumi.Input<string>[]>;
}

export interface SourceKafkaKeyFormatProtobuf {
    message: pulumi.Input<string>;
    schemaRegistryConnection: pulumi.Input<inputs.SourceKafkaKeyFormatProtobufSchemaRegistryConnection>;
}

export interface SourceKafkaKeyFormatProtobufSchemaRegistryConnection {
    /**
     * The identifier for the source database.
     */
    databaseName?: pulumi.Input<string>;
    /**
     * The identifier for the source.
     */
    name: pulumi.Input<string>;
    /**
     * The identifier for the source schema.
     */
    schemaName?: pulumi.Input<string>;
}

export interface SourceKafkaValueFormat {
    /**
     * Avro format.
     */
    avro?: pulumi.Input<inputs.SourceKafkaValueFormatAvro>;
    /**
     * CSV format.
     */
    csvs?: pulumi.Input<pulumi.Input<inputs.SourceKafkaValueFormatCsv>[]>;
    /**
     * JSON format.
     */
    json?: pulumi.Input<boolean>;
    /**
     * Protobuf format.
     */
    protobuf?: pulumi.Input<inputs.SourceKafkaValueFormatProtobuf>;
    /**
     * Text format.
     */
    text?: pulumi.Input<boolean>;
}

export interface SourceKafkaValueFormatAvro {
    keyStrategy?: pulumi.Input<string>;
    schemaRegistryConnection: pulumi.Input<inputs.SourceKafkaValueFormatAvroSchemaRegistryConnection>;
    valueStrategy?: pulumi.Input<string>;
}

export interface SourceKafkaValueFormatAvroSchemaRegistryConnection {
    /**
     * The identifier for the source database.
     */
    databaseName?: pulumi.Input<string>;
    /**
     * The identifier for the source.
     */
    name: pulumi.Input<string>;
    /**
     * The identifier for the source schema.
     */
    schemaName?: pulumi.Input<string>;
}

export interface SourceKafkaValueFormatCsv {
    column?: pulumi.Input<number>;
    delimitedBy?: pulumi.Input<string>;
    headers?: pulumi.Input<pulumi.Input<string>[]>;
}

export interface SourceKafkaValueFormatProtobuf {
    message: pulumi.Input<string>;
    schemaRegistryConnection: pulumi.Input<inputs.SourceKafkaValueFormatProtobufSchemaRegistryConnection>;
}

export interface SourceKafkaValueFormatProtobufSchemaRegistryConnection {
    /**
     * The identifier for the source database.
     */
    databaseName?: pulumi.Input<string>;
    /**
     * The identifier for the source.
     */
    name: pulumi.Input<string>;
    /**
     * The identifier for the source schema.
     */
    schemaName?: pulumi.Input<string>;
}

export interface SourceLoadgenAuctionOption {
    /**
     * The scale factor for the generator. Defaults to 0.01 (~ 10MB).
     */
    scaleFactor?: pulumi.Input<number>;
    /**
     * Creates subsources for specific tables.
     */
    tables?: pulumi.Input<pulumi.Input<inputs.SourceLoadgenAuctionOptionTable>[]>;
    /**
     * The interval at which the next datum should be emitted. Defaults to one second.
     */
    tickInterval?: pulumi.Input<string>;
}

export interface SourceLoadgenAuctionOptionTable {
    alias?: pulumi.Input<string>;
    /**
     * The identifier for the source.
     */
    name: pulumi.Input<string>;
}

export interface SourceLoadgenCounterOption {
    /**
     * Causes the generator to delete old values to keep the collection at most a given size. Defaults to unlimited.
     */
    maxCardinality?: pulumi.Input<number>;
    /**
     * The scale factor for the generator. Defaults to 0.01 (~ 10MB).
     */
    scaleFactor?: pulumi.Input<number>;
    /**
     * The interval at which the next datum should be emitted. Defaults to one second.
     */
    tickInterval?: pulumi.Input<string>;
}

export interface SourceLoadgenTpchOption {
    /**
     * The scale factor for the generator. Defaults to 0.01 (~ 10MB).
     */
    scaleFactor?: pulumi.Input<number>;
    /**
     * Creates subsources for specific tables.
     */
    tables?: pulumi.Input<pulumi.Input<inputs.SourceLoadgenTpchOptionTable>[]>;
    /**
     * The interval at which the next datum should be emitted. Defaults to one second.
     */
    tickInterval?: pulumi.Input<string>;
}

export interface SourceLoadgenTpchOptionTable {
    alias?: pulumi.Input<string>;
    /**
     * The identifier for the source.
     */
    name: pulumi.Input<string>;
}

export interface SourcePostgresPostgresConnection {
    /**
     * The posgresConnection database name.
     */
    databaseName?: pulumi.Input<string>;
    /**
     * The posgresConnection name.
     */
    name: pulumi.Input<string>;
    /**
     * The posgresConnection schema name.
     */
    schemaName?: pulumi.Input<string>;
}

export interface SourcePostgresTable {
    /**
     * The alias of the table.
     */
    alias?: pulumi.Input<string>;
    /**
     * The name of the table.
     */
    name: pulumi.Input<string>;
}

export interface TableColumn {
    /**
     * The name of the column to be created in the table.
     */
    name: pulumi.Input<string>;
    /**
     * Do not allow the column to contain NULL values. Columns without this constraint can contain NULL values.
     */
    nullable?: pulumi.Input<boolean>;
    /**
     * The data type of the column indicated by name.
     */
    type: pulumi.Input<string>;
}
