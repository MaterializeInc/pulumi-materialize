# coding=utf-8
# *** WARNING: this file was generated by the Pulumi Terraform Bridge (tfgen) Tool. ***
# *** Do not edit by hand unless you're certain you know what you are doing! ***

import copy
import warnings
import pulumi
import pulumi.runtime
from typing import Any, Mapping, Optional, Sequence, Union, overload
from . import _utilities
from . import outputs

__all__ = [
    'ConnectionConfluentSchemaRegistryAwsPrivatelink',
    'ConnectionConfluentSchemaRegistryPassword',
    'ConnectionConfluentSchemaRegistrySshTunnel',
    'ConnectionConfluentSchemaRegistrySslCertificate',
    'ConnectionConfluentSchemaRegistrySslCertificateAuthority',
    'ConnectionConfluentSchemaRegistrySslCertificateAuthoritySecret',
    'ConnectionConfluentSchemaRegistrySslCertificateSecret',
    'ConnectionConfluentSchemaRegistrySslKey',
    'ConnectionConfluentSchemaRegistryUsername',
    'ConnectionConfluentSchemaRegistryUsernameSecret',
    'ConnectionKafkaKafkaBroker',
    'ConnectionKafkaKafkaBrokerPrivatelinkConnection',
    'ConnectionKafkaSaslPassword',
    'ConnectionKafkaSaslUsername',
    'ConnectionKafkaSaslUsernameSecret',
    'ConnectionKafkaSshTunnel',
    'ConnectionKafkaSslCertificate',
    'ConnectionKafkaSslCertificateAuthority',
    'ConnectionKafkaSslCertificateAuthoritySecret',
    'ConnectionKafkaSslCertificateSecret',
    'ConnectionKafkaSslKey',
    'ConnectionPostgresAwsPrivatelink',
    'ConnectionPostgresPassword',
    'ConnectionPostgresSshTunnel',
    'ConnectionPostgresSslCertificate',
    'ConnectionPostgresSslCertificateAuthority',
    'ConnectionPostgresSslCertificateAuthoritySecret',
    'ConnectionPostgresSslCertificateSecret',
    'ConnectionPostgresSslKey',
    'ConnectionPostgresUser',
    'ConnectionPostgresUserSecret',
    'GetClusterReplicasClusterReplicaResult',
    'GetClustersClusterResult',
    'GetConnectionsConnectionResult',
    'GetDatabasesDatabaseResult',
    'GetIndexesIndexResult',
    'GetMaterializedViewsMaterializedViewResult',
    'GetSchemasSchemaResult',
    'GetSecretsSecretResult',
    'GetSinksSinkResult',
    'GetSourcesSourceResult',
    'GetTablesTableResult',
    'GetViewsViewResult',
    'IndexColExpr',
    'IndexObjName',
    'SinkKafkaEnvelope',
    'SinkKafkaFormat',
    'SinkKafkaFormatAvro',
    'SinkKafkaFormatAvroSchemaRegistryConnection',
    'SinkKafkaFrom',
    'SinkKafkaKafkaConnection',
    'SourceKafkaEnvelope',
    'SourceKafkaFormat',
    'SourceKafkaFormatAvro',
    'SourceKafkaFormatAvroSchemaRegistryConnection',
    'SourceKafkaFormatCsv',
    'SourceKafkaFormatProtobuf',
    'SourceKafkaFormatProtobufSchemaRegistryConnection',
    'SourceKafkaKafkaConnection',
    'SourceKafkaKeyFormat',
    'SourceKafkaKeyFormatAvro',
    'SourceKafkaKeyFormatAvroSchemaRegistryConnection',
    'SourceKafkaKeyFormatCsv',
    'SourceKafkaKeyFormatProtobuf',
    'SourceKafkaKeyFormatProtobufSchemaRegistryConnection',
    'SourceKafkaValueFormat',
    'SourceKafkaValueFormatAvro',
    'SourceKafkaValueFormatAvroSchemaRegistryConnection',
    'SourceKafkaValueFormatCsv',
    'SourceKafkaValueFormatProtobuf',
    'SourceKafkaValueFormatProtobufSchemaRegistryConnection',
    'SourceLoadgenAuctionOption',
    'SourceLoadgenAuctionOptionTable',
    'SourceLoadgenCounterOption',
    'SourceLoadgenTpchOption',
    'SourceLoadgenTpchOptionTable',
    'SourcePostgresPostgresConnection',
    'SourcePostgresTable',
    'TableColumn',
]

@pulumi.output_type
class ConnectionConfluentSchemaRegistryAwsPrivatelink(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "databaseName":
            suggest = "database_name"
        elif key == "schemaName":
            suggest = "schema_name"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ConnectionConfluentSchemaRegistryAwsPrivatelink. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ConnectionConfluentSchemaRegistryAwsPrivatelink.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ConnectionConfluentSchemaRegistryAwsPrivatelink.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 name: str,
                 database_name: Optional[str] = None,
                 schema_name: Optional[str] = None):
        """
        :param str name: The aws_privatelink name.
        :param str database_name: The aws_privatelink database name.
        :param str schema_name: The aws_privatelink schema name.
        """
        pulumi.set(__self__, "name", name)
        if database_name is not None:
            pulumi.set(__self__, "database_name", database_name)
        if schema_name is not None:
            pulumi.set(__self__, "schema_name", schema_name)

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        The aws_privatelink name.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter(name="databaseName")
    def database_name(self) -> Optional[str]:
        """
        The aws_privatelink database name.
        """
        return pulumi.get(self, "database_name")

    @property
    @pulumi.getter(name="schemaName")
    def schema_name(self) -> Optional[str]:
        """
        The aws_privatelink schema name.
        """
        return pulumi.get(self, "schema_name")


@pulumi.output_type
class ConnectionConfluentSchemaRegistryPassword(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "databaseName":
            suggest = "database_name"
        elif key == "schemaName":
            suggest = "schema_name"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ConnectionConfluentSchemaRegistryPassword. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ConnectionConfluentSchemaRegistryPassword.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ConnectionConfluentSchemaRegistryPassword.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 name: str,
                 database_name: Optional[str] = None,
                 schema_name: Optional[str] = None):
        """
        :param str name: The password name.
        :param str database_name: The password database name.
        :param str schema_name: The password schema name.
        """
        pulumi.set(__self__, "name", name)
        if database_name is not None:
            pulumi.set(__self__, "database_name", database_name)
        if schema_name is not None:
            pulumi.set(__self__, "schema_name", schema_name)

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        The password name.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter(name="databaseName")
    def database_name(self) -> Optional[str]:
        """
        The password database name.
        """
        return pulumi.get(self, "database_name")

    @property
    @pulumi.getter(name="schemaName")
    def schema_name(self) -> Optional[str]:
        """
        The password schema name.
        """
        return pulumi.get(self, "schema_name")


@pulumi.output_type
class ConnectionConfluentSchemaRegistrySshTunnel(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "databaseName":
            suggest = "database_name"
        elif key == "schemaName":
            suggest = "schema_name"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ConnectionConfluentSchemaRegistrySshTunnel. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ConnectionConfluentSchemaRegistrySshTunnel.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ConnectionConfluentSchemaRegistrySshTunnel.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 name: str,
                 database_name: Optional[str] = None,
                 schema_name: Optional[str] = None):
        """
        :param str name: The ssh_tunnel name.
        :param str database_name: The ssh_tunnel database name.
        :param str schema_name: The ssh_tunnel schema name.
        """
        pulumi.set(__self__, "name", name)
        if database_name is not None:
            pulumi.set(__self__, "database_name", database_name)
        if schema_name is not None:
            pulumi.set(__self__, "schema_name", schema_name)

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        The ssh_tunnel name.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter(name="databaseName")
    def database_name(self) -> Optional[str]:
        """
        The ssh_tunnel database name.
        """
        return pulumi.get(self, "database_name")

    @property
    @pulumi.getter(name="schemaName")
    def schema_name(self) -> Optional[str]:
        """
        The ssh_tunnel schema name.
        """
        return pulumi.get(self, "schema_name")


@pulumi.output_type
class ConnectionConfluentSchemaRegistrySslCertificate(dict):
    def __init__(__self__, *,
                 secret: Optional['outputs.ConnectionConfluentSchemaRegistrySslCertificateSecret'] = None,
                 text: Optional[str] = None):
        """
        :param 'ConnectionConfluentSchemaRegistrySslCertificateSecretArgs' secret: The ssl*certificate secret value.
        :param str text: The ssl_certificate text value.
        """
        if secret is not None:
            pulumi.set(__self__, "secret", secret)
        if text is not None:
            pulumi.set(__self__, "text", text)

    @property
    @pulumi.getter
    def secret(self) -> Optional['outputs.ConnectionConfluentSchemaRegistrySslCertificateSecret']:
        """
        The ssl*certificate secret value.
        """
        return pulumi.get(self, "secret")

    @property
    @pulumi.getter
    def text(self) -> Optional[str]:
        """
        The ssl_certificate text value.
        """
        return pulumi.get(self, "text")


@pulumi.output_type
class ConnectionConfluentSchemaRegistrySslCertificateAuthority(dict):
    def __init__(__self__, *,
                 secret: Optional['outputs.ConnectionConfluentSchemaRegistrySslCertificateAuthoritySecret'] = None,
                 text: Optional[str] = None):
        """
        :param 'ConnectionConfluentSchemaRegistrySslCertificateAuthoritySecretArgs' secret: The ssl*certificate*authority secret value.
        :param str text: The ssl*certificate*authority text value.
        """
        if secret is not None:
            pulumi.set(__self__, "secret", secret)
        if text is not None:
            pulumi.set(__self__, "text", text)

    @property
    @pulumi.getter
    def secret(self) -> Optional['outputs.ConnectionConfluentSchemaRegistrySslCertificateAuthoritySecret']:
        """
        The ssl*certificate*authority secret value.
        """
        return pulumi.get(self, "secret")

    @property
    @pulumi.getter
    def text(self) -> Optional[str]:
        """
        The ssl*certificate*authority text value.
        """
        return pulumi.get(self, "text")


@pulumi.output_type
class ConnectionConfluentSchemaRegistrySslCertificateAuthoritySecret(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "databaseName":
            suggest = "database_name"
        elif key == "schemaName":
            suggest = "schema_name"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ConnectionConfluentSchemaRegistrySslCertificateAuthoritySecret. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ConnectionConfluentSchemaRegistrySslCertificateAuthoritySecret.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ConnectionConfluentSchemaRegistrySslCertificateAuthoritySecret.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 name: str,
                 database_name: Optional[str] = None,
                 schema_name: Optional[str] = None):
        """
        :param str name: The identifier for the connection.
        :param str database_name: The identifier for the connection database.
        :param str schema_name: The identifier for the connection schema.
        """
        pulumi.set(__self__, "name", name)
        if database_name is not None:
            pulumi.set(__self__, "database_name", database_name)
        if schema_name is not None:
            pulumi.set(__self__, "schema_name", schema_name)

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        The identifier for the connection.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter(name="databaseName")
    def database_name(self) -> Optional[str]:
        """
        The identifier for the connection database.
        """
        return pulumi.get(self, "database_name")

    @property
    @pulumi.getter(name="schemaName")
    def schema_name(self) -> Optional[str]:
        """
        The identifier for the connection schema.
        """
        return pulumi.get(self, "schema_name")


@pulumi.output_type
class ConnectionConfluentSchemaRegistrySslCertificateSecret(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "databaseName":
            suggest = "database_name"
        elif key == "schemaName":
            suggest = "schema_name"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ConnectionConfluentSchemaRegistrySslCertificateSecret. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ConnectionConfluentSchemaRegistrySslCertificateSecret.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ConnectionConfluentSchemaRegistrySslCertificateSecret.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 name: str,
                 database_name: Optional[str] = None,
                 schema_name: Optional[str] = None):
        """
        :param str name: The identifier for the connection.
        :param str database_name: The identifier for the connection database.
        :param str schema_name: The identifier for the connection schema.
        """
        pulumi.set(__self__, "name", name)
        if database_name is not None:
            pulumi.set(__self__, "database_name", database_name)
        if schema_name is not None:
            pulumi.set(__self__, "schema_name", schema_name)

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        The identifier for the connection.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter(name="databaseName")
    def database_name(self) -> Optional[str]:
        """
        The identifier for the connection database.
        """
        return pulumi.get(self, "database_name")

    @property
    @pulumi.getter(name="schemaName")
    def schema_name(self) -> Optional[str]:
        """
        The identifier for the connection schema.
        """
        return pulumi.get(self, "schema_name")


@pulumi.output_type
class ConnectionConfluentSchemaRegistrySslKey(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "databaseName":
            suggest = "database_name"
        elif key == "schemaName":
            suggest = "schema_name"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ConnectionConfluentSchemaRegistrySslKey. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ConnectionConfluentSchemaRegistrySslKey.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ConnectionConfluentSchemaRegistrySslKey.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 name: str,
                 database_name: Optional[str] = None,
                 schema_name: Optional[str] = None):
        """
        :param str name: The ssl_key name.
        :param str database_name: The ssl_key database name.
        :param str schema_name: The ssl_key schema name.
        """
        pulumi.set(__self__, "name", name)
        if database_name is not None:
            pulumi.set(__self__, "database_name", database_name)
        if schema_name is not None:
            pulumi.set(__self__, "schema_name", schema_name)

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        The ssl_key name.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter(name="databaseName")
    def database_name(self) -> Optional[str]:
        """
        The ssl_key database name.
        """
        return pulumi.get(self, "database_name")

    @property
    @pulumi.getter(name="schemaName")
    def schema_name(self) -> Optional[str]:
        """
        The ssl_key schema name.
        """
        return pulumi.get(self, "schema_name")


@pulumi.output_type
class ConnectionConfluentSchemaRegistryUsername(dict):
    def __init__(__self__, *,
                 secret: Optional['outputs.ConnectionConfluentSchemaRegistryUsernameSecret'] = None,
                 text: Optional[str] = None):
        """
        :param 'ConnectionConfluentSchemaRegistryUsernameSecretArgs' secret: The username secret value.
        :param str text: The username text value.
        """
        if secret is not None:
            pulumi.set(__self__, "secret", secret)
        if text is not None:
            pulumi.set(__self__, "text", text)

    @property
    @pulumi.getter
    def secret(self) -> Optional['outputs.ConnectionConfluentSchemaRegistryUsernameSecret']:
        """
        The username secret value.
        """
        return pulumi.get(self, "secret")

    @property
    @pulumi.getter
    def text(self) -> Optional[str]:
        """
        The username text value.
        """
        return pulumi.get(self, "text")


@pulumi.output_type
class ConnectionConfluentSchemaRegistryUsernameSecret(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "databaseName":
            suggest = "database_name"
        elif key == "schemaName":
            suggest = "schema_name"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ConnectionConfluentSchemaRegistryUsernameSecret. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ConnectionConfluentSchemaRegistryUsernameSecret.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ConnectionConfluentSchemaRegistryUsernameSecret.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 name: str,
                 database_name: Optional[str] = None,
                 schema_name: Optional[str] = None):
        """
        :param str name: The identifier for the connection.
        :param str database_name: The identifier for the connection database.
        :param str schema_name: The identifier for the connection schema.
        """
        pulumi.set(__self__, "name", name)
        if database_name is not None:
            pulumi.set(__self__, "database_name", database_name)
        if schema_name is not None:
            pulumi.set(__self__, "schema_name", schema_name)

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        The identifier for the connection.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter(name="databaseName")
    def database_name(self) -> Optional[str]:
        """
        The identifier for the connection database.
        """
        return pulumi.get(self, "database_name")

    @property
    @pulumi.getter(name="schemaName")
    def schema_name(self) -> Optional[str]:
        """
        The identifier for the connection schema.
        """
        return pulumi.get(self, "schema_name")


@pulumi.output_type
class ConnectionKafkaKafkaBroker(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "availabilityZone":
            suggest = "availability_zone"
        elif key == "privatelinkConnection":
            suggest = "privatelink_connection"
        elif key == "targetGroupPort":
            suggest = "target_group_port"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ConnectionKafkaKafkaBroker. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ConnectionKafkaKafkaBroker.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ConnectionKafkaKafkaBroker.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 broker: str,
                 availability_zone: Optional[str] = None,
                 privatelink_connection: Optional['outputs.ConnectionKafkaKafkaBrokerPrivatelinkConnection'] = None,
                 target_group_port: Optional[int] = None):
        """
        :param str broker: The Kafka broker, in the form of `host:port`.
        :param str availability_zone: The availability zone of the Kafka broker.
        :param 'ConnectionKafkaKafkaBrokerPrivatelinkConnectionArgs' privatelink_connection: The AWS PrivateLink connection name in Materialize.
        :param int target_group_port: The port of the target group associated with the Kafka broker.
        """
        pulumi.set(__self__, "broker", broker)
        if availability_zone is not None:
            pulumi.set(__self__, "availability_zone", availability_zone)
        if privatelink_connection is not None:
            pulumi.set(__self__, "privatelink_connection", privatelink_connection)
        if target_group_port is not None:
            pulumi.set(__self__, "target_group_port", target_group_port)

    @property
    @pulumi.getter
    def broker(self) -> str:
        """
        The Kafka broker, in the form of `host:port`.
        """
        return pulumi.get(self, "broker")

    @property
    @pulumi.getter(name="availabilityZone")
    def availability_zone(self) -> Optional[str]:
        """
        The availability zone of the Kafka broker.
        """
        return pulumi.get(self, "availability_zone")

    @property
    @pulumi.getter(name="privatelinkConnection")
    def privatelink_connection(self) -> Optional['outputs.ConnectionKafkaKafkaBrokerPrivatelinkConnection']:
        """
        The AWS PrivateLink connection name in Materialize.
        """
        return pulumi.get(self, "privatelink_connection")

    @property
    @pulumi.getter(name="targetGroupPort")
    def target_group_port(self) -> Optional[int]:
        """
        The port of the target group associated with the Kafka broker.
        """
        return pulumi.get(self, "target_group_port")


@pulumi.output_type
class ConnectionKafkaKafkaBrokerPrivatelinkConnection(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "databaseName":
            suggest = "database_name"
        elif key == "schemaName":
            suggest = "schema_name"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ConnectionKafkaKafkaBrokerPrivatelinkConnection. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ConnectionKafkaKafkaBrokerPrivatelinkConnection.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ConnectionKafkaKafkaBrokerPrivatelinkConnection.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 name: str,
                 database_name: Optional[str] = None,
                 schema_name: Optional[str] = None):
        """
        :param str name: The identifier for the connection.
        :param str database_name: The identifier for the connection database.
        :param str schema_name: The identifier for the connection schema.
        """
        pulumi.set(__self__, "name", name)
        if database_name is not None:
            pulumi.set(__self__, "database_name", database_name)
        if schema_name is not None:
            pulumi.set(__self__, "schema_name", schema_name)

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        The identifier for the connection.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter(name="databaseName")
    def database_name(self) -> Optional[str]:
        """
        The identifier for the connection database.
        """
        return pulumi.get(self, "database_name")

    @property
    @pulumi.getter(name="schemaName")
    def schema_name(self) -> Optional[str]:
        """
        The identifier for the connection schema.
        """
        return pulumi.get(self, "schema_name")


@pulumi.output_type
class ConnectionKafkaSaslPassword(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "databaseName":
            suggest = "database_name"
        elif key == "schemaName":
            suggest = "schema_name"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ConnectionKafkaSaslPassword. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ConnectionKafkaSaslPassword.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ConnectionKafkaSaslPassword.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 name: str,
                 database_name: Optional[str] = None,
                 schema_name: Optional[str] = None):
        """
        :param str name: The sasl_password name.
        :param str database_name: The sasl_password database name.
        :param str schema_name: The sasl_password schema name.
        """
        pulumi.set(__self__, "name", name)
        if database_name is not None:
            pulumi.set(__self__, "database_name", database_name)
        if schema_name is not None:
            pulumi.set(__self__, "schema_name", schema_name)

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        The sasl_password name.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter(name="databaseName")
    def database_name(self) -> Optional[str]:
        """
        The sasl_password database name.
        """
        return pulumi.get(self, "database_name")

    @property
    @pulumi.getter(name="schemaName")
    def schema_name(self) -> Optional[str]:
        """
        The sasl_password schema name.
        """
        return pulumi.get(self, "schema_name")


@pulumi.output_type
class ConnectionKafkaSaslUsername(dict):
    def __init__(__self__, *,
                 secret: Optional['outputs.ConnectionKafkaSaslUsernameSecret'] = None,
                 text: Optional[str] = None):
        """
        :param 'ConnectionKafkaSaslUsernameSecretArgs' secret: The sasl*username secret value.
        :param str text: The sasl_username text value.
        """
        if secret is not None:
            pulumi.set(__self__, "secret", secret)
        if text is not None:
            pulumi.set(__self__, "text", text)

    @property
    @pulumi.getter
    def secret(self) -> Optional['outputs.ConnectionKafkaSaslUsernameSecret']:
        """
        The sasl*username secret value.
        """
        return pulumi.get(self, "secret")

    @property
    @pulumi.getter
    def text(self) -> Optional[str]:
        """
        The sasl_username text value.
        """
        return pulumi.get(self, "text")


@pulumi.output_type
class ConnectionKafkaSaslUsernameSecret(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "databaseName":
            suggest = "database_name"
        elif key == "schemaName":
            suggest = "schema_name"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ConnectionKafkaSaslUsernameSecret. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ConnectionKafkaSaslUsernameSecret.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ConnectionKafkaSaslUsernameSecret.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 name: str,
                 database_name: Optional[str] = None,
                 schema_name: Optional[str] = None):
        """
        :param str name: The identifier for the connection.
        :param str database_name: The identifier for the connection database.
        :param str schema_name: The identifier for the connection schema.
        """
        pulumi.set(__self__, "name", name)
        if database_name is not None:
            pulumi.set(__self__, "database_name", database_name)
        if schema_name is not None:
            pulumi.set(__self__, "schema_name", schema_name)

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        The identifier for the connection.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter(name="databaseName")
    def database_name(self) -> Optional[str]:
        """
        The identifier for the connection database.
        """
        return pulumi.get(self, "database_name")

    @property
    @pulumi.getter(name="schemaName")
    def schema_name(self) -> Optional[str]:
        """
        The identifier for the connection schema.
        """
        return pulumi.get(self, "schema_name")


@pulumi.output_type
class ConnectionKafkaSshTunnel(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "databaseName":
            suggest = "database_name"
        elif key == "schemaName":
            suggest = "schema_name"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ConnectionKafkaSshTunnel. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ConnectionKafkaSshTunnel.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ConnectionKafkaSshTunnel.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 name: str,
                 database_name: Optional[str] = None,
                 schema_name: Optional[str] = None):
        """
        :param str name: The ssh_tunnel name.
        :param str database_name: The ssh_tunnel database name.
        :param str schema_name: The ssh_tunnel schema name.
        """
        pulumi.set(__self__, "name", name)
        if database_name is not None:
            pulumi.set(__self__, "database_name", database_name)
        if schema_name is not None:
            pulumi.set(__self__, "schema_name", schema_name)

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        The ssh_tunnel name.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter(name="databaseName")
    def database_name(self) -> Optional[str]:
        """
        The ssh_tunnel database name.
        """
        return pulumi.get(self, "database_name")

    @property
    @pulumi.getter(name="schemaName")
    def schema_name(self) -> Optional[str]:
        """
        The ssh_tunnel schema name.
        """
        return pulumi.get(self, "schema_name")


@pulumi.output_type
class ConnectionKafkaSslCertificate(dict):
    def __init__(__self__, *,
                 secret: Optional['outputs.ConnectionKafkaSslCertificateSecret'] = None,
                 text: Optional[str] = None):
        """
        :param 'ConnectionKafkaSslCertificateSecretArgs' secret: The ssl*certificate secret value.
        :param str text: The ssl_certificate text value.
        """
        if secret is not None:
            pulumi.set(__self__, "secret", secret)
        if text is not None:
            pulumi.set(__self__, "text", text)

    @property
    @pulumi.getter
    def secret(self) -> Optional['outputs.ConnectionKafkaSslCertificateSecret']:
        """
        The ssl*certificate secret value.
        """
        return pulumi.get(self, "secret")

    @property
    @pulumi.getter
    def text(self) -> Optional[str]:
        """
        The ssl_certificate text value.
        """
        return pulumi.get(self, "text")


@pulumi.output_type
class ConnectionKafkaSslCertificateAuthority(dict):
    def __init__(__self__, *,
                 secret: Optional['outputs.ConnectionKafkaSslCertificateAuthoritySecret'] = None,
                 text: Optional[str] = None):
        """
        :param 'ConnectionKafkaSslCertificateAuthoritySecretArgs' secret: The ssl*certificate*authority secret value.
        :param str text: The ssl*certificate*authority text value.
        """
        if secret is not None:
            pulumi.set(__self__, "secret", secret)
        if text is not None:
            pulumi.set(__self__, "text", text)

    @property
    @pulumi.getter
    def secret(self) -> Optional['outputs.ConnectionKafkaSslCertificateAuthoritySecret']:
        """
        The ssl*certificate*authority secret value.
        """
        return pulumi.get(self, "secret")

    @property
    @pulumi.getter
    def text(self) -> Optional[str]:
        """
        The ssl*certificate*authority text value.
        """
        return pulumi.get(self, "text")


@pulumi.output_type
class ConnectionKafkaSslCertificateAuthoritySecret(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "databaseName":
            suggest = "database_name"
        elif key == "schemaName":
            suggest = "schema_name"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ConnectionKafkaSslCertificateAuthoritySecret. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ConnectionKafkaSslCertificateAuthoritySecret.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ConnectionKafkaSslCertificateAuthoritySecret.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 name: str,
                 database_name: Optional[str] = None,
                 schema_name: Optional[str] = None):
        """
        :param str name: The identifier for the connection.
        :param str database_name: The identifier for the connection database.
        :param str schema_name: The identifier for the connection schema.
        """
        pulumi.set(__self__, "name", name)
        if database_name is not None:
            pulumi.set(__self__, "database_name", database_name)
        if schema_name is not None:
            pulumi.set(__self__, "schema_name", schema_name)

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        The identifier for the connection.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter(name="databaseName")
    def database_name(self) -> Optional[str]:
        """
        The identifier for the connection database.
        """
        return pulumi.get(self, "database_name")

    @property
    @pulumi.getter(name="schemaName")
    def schema_name(self) -> Optional[str]:
        """
        The identifier for the connection schema.
        """
        return pulumi.get(self, "schema_name")


@pulumi.output_type
class ConnectionKafkaSslCertificateSecret(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "databaseName":
            suggest = "database_name"
        elif key == "schemaName":
            suggest = "schema_name"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ConnectionKafkaSslCertificateSecret. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ConnectionKafkaSslCertificateSecret.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ConnectionKafkaSslCertificateSecret.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 name: str,
                 database_name: Optional[str] = None,
                 schema_name: Optional[str] = None):
        """
        :param str name: The identifier for the connection.
        :param str database_name: The identifier for the connection database.
        :param str schema_name: The identifier for the connection schema.
        """
        pulumi.set(__self__, "name", name)
        if database_name is not None:
            pulumi.set(__self__, "database_name", database_name)
        if schema_name is not None:
            pulumi.set(__self__, "schema_name", schema_name)

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        The identifier for the connection.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter(name="databaseName")
    def database_name(self) -> Optional[str]:
        """
        The identifier for the connection database.
        """
        return pulumi.get(self, "database_name")

    @property
    @pulumi.getter(name="schemaName")
    def schema_name(self) -> Optional[str]:
        """
        The identifier for the connection schema.
        """
        return pulumi.get(self, "schema_name")


@pulumi.output_type
class ConnectionKafkaSslKey(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "databaseName":
            suggest = "database_name"
        elif key == "schemaName":
            suggest = "schema_name"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ConnectionKafkaSslKey. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ConnectionKafkaSslKey.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ConnectionKafkaSslKey.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 name: str,
                 database_name: Optional[str] = None,
                 schema_name: Optional[str] = None):
        """
        :param str name: The ssl_key name.
        :param str database_name: The ssl_key database name.
        :param str schema_name: The ssl_key schema name.
        """
        pulumi.set(__self__, "name", name)
        if database_name is not None:
            pulumi.set(__self__, "database_name", database_name)
        if schema_name is not None:
            pulumi.set(__self__, "schema_name", schema_name)

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        The ssl_key name.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter(name="databaseName")
    def database_name(self) -> Optional[str]:
        """
        The ssl_key database name.
        """
        return pulumi.get(self, "database_name")

    @property
    @pulumi.getter(name="schemaName")
    def schema_name(self) -> Optional[str]:
        """
        The ssl_key schema name.
        """
        return pulumi.get(self, "schema_name")


@pulumi.output_type
class ConnectionPostgresAwsPrivatelink(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "databaseName":
            suggest = "database_name"
        elif key == "schemaName":
            suggest = "schema_name"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ConnectionPostgresAwsPrivatelink. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ConnectionPostgresAwsPrivatelink.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ConnectionPostgresAwsPrivatelink.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 name: str,
                 database_name: Optional[str] = None,
                 schema_name: Optional[str] = None):
        """
        :param str name: The aws_privatelink name.
        :param str database_name: The aws_privatelink database name.
        :param str schema_name: The aws_privatelink schema name.
        """
        pulumi.set(__self__, "name", name)
        if database_name is not None:
            pulumi.set(__self__, "database_name", database_name)
        if schema_name is not None:
            pulumi.set(__self__, "schema_name", schema_name)

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        The aws_privatelink name.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter(name="databaseName")
    def database_name(self) -> Optional[str]:
        """
        The aws_privatelink database name.
        """
        return pulumi.get(self, "database_name")

    @property
    @pulumi.getter(name="schemaName")
    def schema_name(self) -> Optional[str]:
        """
        The aws_privatelink schema name.
        """
        return pulumi.get(self, "schema_name")


@pulumi.output_type
class ConnectionPostgresPassword(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "databaseName":
            suggest = "database_name"
        elif key == "schemaName":
            suggest = "schema_name"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ConnectionPostgresPassword. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ConnectionPostgresPassword.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ConnectionPostgresPassword.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 name: str,
                 database_name: Optional[str] = None,
                 schema_name: Optional[str] = None):
        """
        :param str name: The password name.
        :param str database_name: The password database name.
        :param str schema_name: The password schema name.
        """
        pulumi.set(__self__, "name", name)
        if database_name is not None:
            pulumi.set(__self__, "database_name", database_name)
        if schema_name is not None:
            pulumi.set(__self__, "schema_name", schema_name)

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        The password name.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter(name="databaseName")
    def database_name(self) -> Optional[str]:
        """
        The password database name.
        """
        return pulumi.get(self, "database_name")

    @property
    @pulumi.getter(name="schemaName")
    def schema_name(self) -> Optional[str]:
        """
        The password schema name.
        """
        return pulumi.get(self, "schema_name")


@pulumi.output_type
class ConnectionPostgresSshTunnel(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "databaseName":
            suggest = "database_name"
        elif key == "schemaName":
            suggest = "schema_name"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ConnectionPostgresSshTunnel. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ConnectionPostgresSshTunnel.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ConnectionPostgresSshTunnel.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 name: str,
                 database_name: Optional[str] = None,
                 schema_name: Optional[str] = None):
        """
        :param str name: The ssh_tunnel name.
        :param str database_name: The ssh_tunnel database name.
        :param str schema_name: The ssh_tunnel schema name.
        """
        pulumi.set(__self__, "name", name)
        if database_name is not None:
            pulumi.set(__self__, "database_name", database_name)
        if schema_name is not None:
            pulumi.set(__self__, "schema_name", schema_name)

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        The ssh_tunnel name.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter(name="databaseName")
    def database_name(self) -> Optional[str]:
        """
        The ssh_tunnel database name.
        """
        return pulumi.get(self, "database_name")

    @property
    @pulumi.getter(name="schemaName")
    def schema_name(self) -> Optional[str]:
        """
        The ssh_tunnel schema name.
        """
        return pulumi.get(self, "schema_name")


@pulumi.output_type
class ConnectionPostgresSslCertificate(dict):
    def __init__(__self__, *,
                 secret: Optional['outputs.ConnectionPostgresSslCertificateSecret'] = None,
                 text: Optional[str] = None):
        """
        :param 'ConnectionPostgresSslCertificateSecretArgs' secret: The ssl*certificate secret value.
        :param str text: The ssl_certificate text value.
        """
        if secret is not None:
            pulumi.set(__self__, "secret", secret)
        if text is not None:
            pulumi.set(__self__, "text", text)

    @property
    @pulumi.getter
    def secret(self) -> Optional['outputs.ConnectionPostgresSslCertificateSecret']:
        """
        The ssl*certificate secret value.
        """
        return pulumi.get(self, "secret")

    @property
    @pulumi.getter
    def text(self) -> Optional[str]:
        """
        The ssl_certificate text value.
        """
        return pulumi.get(self, "text")


@pulumi.output_type
class ConnectionPostgresSslCertificateAuthority(dict):
    def __init__(__self__, *,
                 secret: Optional['outputs.ConnectionPostgresSslCertificateAuthoritySecret'] = None,
                 text: Optional[str] = None):
        """
        :param 'ConnectionPostgresSslCertificateAuthoritySecretArgs' secret: The ssl*certificate*authority secret value.
        :param str text: The ssl*certificate*authority text value.
        """
        if secret is not None:
            pulumi.set(__self__, "secret", secret)
        if text is not None:
            pulumi.set(__self__, "text", text)

    @property
    @pulumi.getter
    def secret(self) -> Optional['outputs.ConnectionPostgresSslCertificateAuthoritySecret']:
        """
        The ssl*certificate*authority secret value.
        """
        return pulumi.get(self, "secret")

    @property
    @pulumi.getter
    def text(self) -> Optional[str]:
        """
        The ssl*certificate*authority text value.
        """
        return pulumi.get(self, "text")


@pulumi.output_type
class ConnectionPostgresSslCertificateAuthoritySecret(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "databaseName":
            suggest = "database_name"
        elif key == "schemaName":
            suggest = "schema_name"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ConnectionPostgresSslCertificateAuthoritySecret. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ConnectionPostgresSslCertificateAuthoritySecret.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ConnectionPostgresSslCertificateAuthoritySecret.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 name: str,
                 database_name: Optional[str] = None,
                 schema_name: Optional[str] = None):
        """
        :param str name: The identifier for the connection.
        :param str database_name: The identifier for the connection database.
        :param str schema_name: The identifier for the connection schema.
        """
        pulumi.set(__self__, "name", name)
        if database_name is not None:
            pulumi.set(__self__, "database_name", database_name)
        if schema_name is not None:
            pulumi.set(__self__, "schema_name", schema_name)

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        The identifier for the connection.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter(name="databaseName")
    def database_name(self) -> Optional[str]:
        """
        The identifier for the connection database.
        """
        return pulumi.get(self, "database_name")

    @property
    @pulumi.getter(name="schemaName")
    def schema_name(self) -> Optional[str]:
        """
        The identifier for the connection schema.
        """
        return pulumi.get(self, "schema_name")


@pulumi.output_type
class ConnectionPostgresSslCertificateSecret(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "databaseName":
            suggest = "database_name"
        elif key == "schemaName":
            suggest = "schema_name"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ConnectionPostgresSslCertificateSecret. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ConnectionPostgresSslCertificateSecret.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ConnectionPostgresSslCertificateSecret.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 name: str,
                 database_name: Optional[str] = None,
                 schema_name: Optional[str] = None):
        """
        :param str name: The identifier for the connection.
        :param str database_name: The identifier for the connection database.
        :param str schema_name: The identifier for the connection schema.
        """
        pulumi.set(__self__, "name", name)
        if database_name is not None:
            pulumi.set(__self__, "database_name", database_name)
        if schema_name is not None:
            pulumi.set(__self__, "schema_name", schema_name)

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        The identifier for the connection.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter(name="databaseName")
    def database_name(self) -> Optional[str]:
        """
        The identifier for the connection database.
        """
        return pulumi.get(self, "database_name")

    @property
    @pulumi.getter(name="schemaName")
    def schema_name(self) -> Optional[str]:
        """
        The identifier for the connection schema.
        """
        return pulumi.get(self, "schema_name")


@pulumi.output_type
class ConnectionPostgresSslKey(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "databaseName":
            suggest = "database_name"
        elif key == "schemaName":
            suggest = "schema_name"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ConnectionPostgresSslKey. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ConnectionPostgresSslKey.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ConnectionPostgresSslKey.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 name: str,
                 database_name: Optional[str] = None,
                 schema_name: Optional[str] = None):
        """
        :param str name: The ssl_key name.
        :param str database_name: The ssl_key database name.
        :param str schema_name: The ssl_key schema name.
        """
        pulumi.set(__self__, "name", name)
        if database_name is not None:
            pulumi.set(__self__, "database_name", database_name)
        if schema_name is not None:
            pulumi.set(__self__, "schema_name", schema_name)

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        The ssl_key name.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter(name="databaseName")
    def database_name(self) -> Optional[str]:
        """
        The ssl_key database name.
        """
        return pulumi.get(self, "database_name")

    @property
    @pulumi.getter(name="schemaName")
    def schema_name(self) -> Optional[str]:
        """
        The ssl_key schema name.
        """
        return pulumi.get(self, "schema_name")


@pulumi.output_type
class ConnectionPostgresUser(dict):
    def __init__(__self__, *,
                 secret: Optional['outputs.ConnectionPostgresUserSecret'] = None,
                 text: Optional[str] = None):
        """
        :param 'ConnectionPostgresUserSecretArgs' secret: The user secret value.
        :param str text: The user text value.
        """
        if secret is not None:
            pulumi.set(__self__, "secret", secret)
        if text is not None:
            pulumi.set(__self__, "text", text)

    @property
    @pulumi.getter
    def secret(self) -> Optional['outputs.ConnectionPostgresUserSecret']:
        """
        The user secret value.
        """
        return pulumi.get(self, "secret")

    @property
    @pulumi.getter
    def text(self) -> Optional[str]:
        """
        The user text value.
        """
        return pulumi.get(self, "text")


@pulumi.output_type
class ConnectionPostgresUserSecret(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "databaseName":
            suggest = "database_name"
        elif key == "schemaName":
            suggest = "schema_name"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ConnectionPostgresUserSecret. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ConnectionPostgresUserSecret.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ConnectionPostgresUserSecret.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 name: str,
                 database_name: Optional[str] = None,
                 schema_name: Optional[str] = None):
        """
        :param str name: The identifier for the connection.
        :param str database_name: The identifier for the connection database.
        :param str schema_name: The identifier for the connection schema.
        """
        pulumi.set(__self__, "name", name)
        if database_name is not None:
            pulumi.set(__self__, "database_name", database_name)
        if schema_name is not None:
            pulumi.set(__self__, "schema_name", schema_name)

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        The identifier for the connection.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter(name="databaseName")
    def database_name(self) -> Optional[str]:
        """
        The identifier for the connection database.
        """
        return pulumi.get(self, "database_name")

    @property
    @pulumi.getter(name="schemaName")
    def schema_name(self) -> Optional[str]:
        """
        The identifier for the connection schema.
        """
        return pulumi.get(self, "schema_name")


@pulumi.output_type
class GetClusterReplicasClusterReplicaResult(dict):
    def __init__(__self__, *,
                 availability_zone: str,
                 cluster: str,
                 id: str,
                 name: str,
                 size: str):
        """
        :param str id: The ID of this resource.
        """
        pulumi.set(__self__, "availability_zone", availability_zone)
        pulumi.set(__self__, "cluster", cluster)
        pulumi.set(__self__, "id", id)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "size", size)

    @property
    @pulumi.getter(name="availabilityZone")
    def availability_zone(self) -> str:
        return pulumi.get(self, "availability_zone")

    @property
    @pulumi.getter
    def cluster(self) -> str:
        return pulumi.get(self, "cluster")

    @property
    @pulumi.getter
    def id(self) -> str:
        """
        The ID of this resource.
        """
        return pulumi.get(self, "id")

    @property
    @pulumi.getter
    def name(self) -> str:
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def size(self) -> str:
        return pulumi.get(self, "size")


@pulumi.output_type
class GetClustersClusterResult(dict):
    def __init__(__self__, *,
                 id: str,
                 name: str):
        """
        :param str id: The ID of this resource.
        """
        pulumi.set(__self__, "id", id)
        pulumi.set(__self__, "name", name)

    @property
    @pulumi.getter
    def id(self) -> str:
        """
        The ID of this resource.
        """
        return pulumi.get(self, "id")

    @property
    @pulumi.getter
    def name(self) -> str:
        return pulumi.get(self, "name")


@pulumi.output_type
class GetConnectionsConnectionResult(dict):
    def __init__(__self__, *,
                 database_name: str,
                 id: str,
                 name: str,
                 schema_name: str,
                 type: str):
        """
        :param str database_name: Limit connections to a specific database
        :param str id: The ID of this resource.
        :param str schema_name: Limit connections to a specific schema within a specific database
        """
        pulumi.set(__self__, "database_name", database_name)
        pulumi.set(__self__, "id", id)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "schema_name", schema_name)
        pulumi.set(__self__, "type", type)

    @property
    @pulumi.getter(name="databaseName")
    def database_name(self) -> str:
        """
        Limit connections to a specific database
        """
        return pulumi.get(self, "database_name")

    @property
    @pulumi.getter
    def id(self) -> str:
        """
        The ID of this resource.
        """
        return pulumi.get(self, "id")

    @property
    @pulumi.getter
    def name(self) -> str:
        return pulumi.get(self, "name")

    @property
    @pulumi.getter(name="schemaName")
    def schema_name(self) -> str:
        """
        Limit connections to a specific schema within a specific database
        """
        return pulumi.get(self, "schema_name")

    @property
    @pulumi.getter
    def type(self) -> str:
        return pulumi.get(self, "type")


@pulumi.output_type
class GetDatabasesDatabaseResult(dict):
    def __init__(__self__, *,
                 id: str,
                 name: str):
        """
        :param str id: The ID of this resource.
        """
        pulumi.set(__self__, "id", id)
        pulumi.set(__self__, "name", name)

    @property
    @pulumi.getter
    def id(self) -> str:
        """
        The ID of this resource.
        """
        return pulumi.get(self, "id")

    @property
    @pulumi.getter
    def name(self) -> str:
        return pulumi.get(self, "name")


@pulumi.output_type
class GetIndexesIndexResult(dict):
    def __init__(__self__, *,
                 id: str,
                 name: str,
                 obj_database: str,
                 obj_name: str,
                 obj_schema: str):
        """
        :param str id: The ID of this resource.
        """
        pulumi.set(__self__, "id", id)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "obj_database", obj_database)
        pulumi.set(__self__, "obj_name", obj_name)
        pulumi.set(__self__, "obj_schema", obj_schema)

    @property
    @pulumi.getter
    def id(self) -> str:
        """
        The ID of this resource.
        """
        return pulumi.get(self, "id")

    @property
    @pulumi.getter
    def name(self) -> str:
        return pulumi.get(self, "name")

    @property
    @pulumi.getter(name="objDatabase")
    def obj_database(self) -> str:
        return pulumi.get(self, "obj_database")

    @property
    @pulumi.getter(name="objName")
    def obj_name(self) -> str:
        return pulumi.get(self, "obj_name")

    @property
    @pulumi.getter(name="objSchema")
    def obj_schema(self) -> str:
        return pulumi.get(self, "obj_schema")


@pulumi.output_type
class GetMaterializedViewsMaterializedViewResult(dict):
    def __init__(__self__, *,
                 database_name: str,
                 id: str,
                 name: str,
                 schema_name: str):
        """
        :param str database_name: Limit materialized views to a specific database
        :param str id: The ID of this resource.
        :param str schema_name: Limit materialized views to a specific schema within a specific database
        """
        pulumi.set(__self__, "database_name", database_name)
        pulumi.set(__self__, "id", id)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "schema_name", schema_name)

    @property
    @pulumi.getter(name="databaseName")
    def database_name(self) -> str:
        """
        Limit materialized views to a specific database
        """
        return pulumi.get(self, "database_name")

    @property
    @pulumi.getter
    def id(self) -> str:
        """
        The ID of this resource.
        """
        return pulumi.get(self, "id")

    @property
    @pulumi.getter
    def name(self) -> str:
        return pulumi.get(self, "name")

    @property
    @pulumi.getter(name="schemaName")
    def schema_name(self) -> str:
        """
        Limit materialized views to a specific schema within a specific database
        """
        return pulumi.get(self, "schema_name")


@pulumi.output_type
class GetSchemasSchemaResult(dict):
    def __init__(__self__, *,
                 database_name: str,
                 id: str,
                 name: str):
        """
        :param str database_name: Limit schemas to a specific database
        :param str id: The ID of this resource.
        """
        pulumi.set(__self__, "database_name", database_name)
        pulumi.set(__self__, "id", id)
        pulumi.set(__self__, "name", name)

    @property
    @pulumi.getter(name="databaseName")
    def database_name(self) -> str:
        """
        Limit schemas to a specific database
        """
        return pulumi.get(self, "database_name")

    @property
    @pulumi.getter
    def id(self) -> str:
        """
        The ID of this resource.
        """
        return pulumi.get(self, "id")

    @property
    @pulumi.getter
    def name(self) -> str:
        return pulumi.get(self, "name")


@pulumi.output_type
class GetSecretsSecretResult(dict):
    def __init__(__self__, *,
                 database_name: str,
                 id: str,
                 name: str,
                 schema_name: str):
        """
        :param str database_name: Limit secrets to a specific database
        :param str id: The ID of this resource.
        :param str schema_name: Limit secrets to a specific schema within a specific database
        """
        pulumi.set(__self__, "database_name", database_name)
        pulumi.set(__self__, "id", id)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "schema_name", schema_name)

    @property
    @pulumi.getter(name="databaseName")
    def database_name(self) -> str:
        """
        Limit secrets to a specific database
        """
        return pulumi.get(self, "database_name")

    @property
    @pulumi.getter
    def id(self) -> str:
        """
        The ID of this resource.
        """
        return pulumi.get(self, "id")

    @property
    @pulumi.getter
    def name(self) -> str:
        return pulumi.get(self, "name")

    @property
    @pulumi.getter(name="schemaName")
    def schema_name(self) -> str:
        """
        Limit secrets to a specific schema within a specific database
        """
        return pulumi.get(self, "schema_name")


@pulumi.output_type
class GetSinksSinkResult(dict):
    def __init__(__self__, *,
                 cluster_name: str,
                 connection_name: str,
                 database_name: str,
                 envelope_type: str,
                 id: str,
                 name: str,
                 schema_name: str,
                 size: str,
                 type: str):
        """
        :param str database_name: Limit sinks to a specific database
        :param str id: The ID of this resource.
        :param str schema_name: Limit sinks to a specific schema within a specific database
        """
        pulumi.set(__self__, "cluster_name", cluster_name)
        pulumi.set(__self__, "connection_name", connection_name)
        pulumi.set(__self__, "database_name", database_name)
        pulumi.set(__self__, "envelope_type", envelope_type)
        pulumi.set(__self__, "id", id)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "schema_name", schema_name)
        pulumi.set(__self__, "size", size)
        pulumi.set(__self__, "type", type)

    @property
    @pulumi.getter(name="clusterName")
    def cluster_name(self) -> str:
        return pulumi.get(self, "cluster_name")

    @property
    @pulumi.getter(name="connectionName")
    def connection_name(self) -> str:
        return pulumi.get(self, "connection_name")

    @property
    @pulumi.getter(name="databaseName")
    def database_name(self) -> str:
        """
        Limit sinks to a specific database
        """
        return pulumi.get(self, "database_name")

    @property
    @pulumi.getter(name="envelopeType")
    def envelope_type(self) -> str:
        return pulumi.get(self, "envelope_type")

    @property
    @pulumi.getter
    def id(self) -> str:
        """
        The ID of this resource.
        """
        return pulumi.get(self, "id")

    @property
    @pulumi.getter
    def name(self) -> str:
        return pulumi.get(self, "name")

    @property
    @pulumi.getter(name="schemaName")
    def schema_name(self) -> str:
        """
        Limit sinks to a specific schema within a specific database
        """
        return pulumi.get(self, "schema_name")

    @property
    @pulumi.getter
    def size(self) -> str:
        return pulumi.get(self, "size")

    @property
    @pulumi.getter
    def type(self) -> str:
        return pulumi.get(self, "type")


@pulumi.output_type
class GetSourcesSourceResult(dict):
    def __init__(__self__, *,
                 cluster_name: str,
                 connection_name: str,
                 database_name: str,
                 envelope_type: str,
                 id: str,
                 name: str,
                 schema_name: str,
                 size: str,
                 type: str):
        """
        :param str database_name: Limit sources to a specific database
        :param str id: The ID of this resource.
        :param str schema_name: Limit sources to a specific schema within a specific database
        """
        pulumi.set(__self__, "cluster_name", cluster_name)
        pulumi.set(__self__, "connection_name", connection_name)
        pulumi.set(__self__, "database_name", database_name)
        pulumi.set(__self__, "envelope_type", envelope_type)
        pulumi.set(__self__, "id", id)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "schema_name", schema_name)
        pulumi.set(__self__, "size", size)
        pulumi.set(__self__, "type", type)

    @property
    @pulumi.getter(name="clusterName")
    def cluster_name(self) -> str:
        return pulumi.get(self, "cluster_name")

    @property
    @pulumi.getter(name="connectionName")
    def connection_name(self) -> str:
        return pulumi.get(self, "connection_name")

    @property
    @pulumi.getter(name="databaseName")
    def database_name(self) -> str:
        """
        Limit sources to a specific database
        """
        return pulumi.get(self, "database_name")

    @property
    @pulumi.getter(name="envelopeType")
    def envelope_type(self) -> str:
        return pulumi.get(self, "envelope_type")

    @property
    @pulumi.getter
    def id(self) -> str:
        """
        The ID of this resource.
        """
        return pulumi.get(self, "id")

    @property
    @pulumi.getter
    def name(self) -> str:
        return pulumi.get(self, "name")

    @property
    @pulumi.getter(name="schemaName")
    def schema_name(self) -> str:
        """
        Limit sources to a specific schema within a specific database
        """
        return pulumi.get(self, "schema_name")

    @property
    @pulumi.getter
    def size(self) -> str:
        return pulumi.get(self, "size")

    @property
    @pulumi.getter
    def type(self) -> str:
        return pulumi.get(self, "type")


@pulumi.output_type
class GetTablesTableResult(dict):
    def __init__(__self__, *,
                 database_name: str,
                 id: str,
                 name: str,
                 schema_name: str):
        """
        :param str database_name: Limit tables to a specific database
        :param str id: The ID of this resource.
        :param str schema_name: Limit tables to a specific schema within a specific database
        """
        pulumi.set(__self__, "database_name", database_name)
        pulumi.set(__self__, "id", id)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "schema_name", schema_name)

    @property
    @pulumi.getter(name="databaseName")
    def database_name(self) -> str:
        """
        Limit tables to a specific database
        """
        return pulumi.get(self, "database_name")

    @property
    @pulumi.getter
    def id(self) -> str:
        """
        The ID of this resource.
        """
        return pulumi.get(self, "id")

    @property
    @pulumi.getter
    def name(self) -> str:
        return pulumi.get(self, "name")

    @property
    @pulumi.getter(name="schemaName")
    def schema_name(self) -> str:
        """
        Limit tables to a specific schema within a specific database
        """
        return pulumi.get(self, "schema_name")


@pulumi.output_type
class GetViewsViewResult(dict):
    def __init__(__self__, *,
                 database_name: str,
                 id: str,
                 name: str,
                 schema_name: str):
        """
        :param str database_name: Limit views to a specific database
        :param str id: The ID of this resource.
        :param str schema_name: Limit views to a specific schema within a specific database
        """
        pulumi.set(__self__, "database_name", database_name)
        pulumi.set(__self__, "id", id)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "schema_name", schema_name)

    @property
    @pulumi.getter(name="databaseName")
    def database_name(self) -> str:
        """
        Limit views to a specific database
        """
        return pulumi.get(self, "database_name")

    @property
    @pulumi.getter
    def id(self) -> str:
        """
        The ID of this resource.
        """
        return pulumi.get(self, "id")

    @property
    @pulumi.getter
    def name(self) -> str:
        return pulumi.get(self, "name")

    @property
    @pulumi.getter(name="schemaName")
    def schema_name(self) -> str:
        """
        Limit views to a specific schema within a specific database
        """
        return pulumi.get(self, "schema_name")


@pulumi.output_type
class IndexColExpr(dict):
    def __init__(__self__, *,
                 field: str,
                 val: Optional[str] = None):
        """
        :param str field: The name of the option you want to set.
        :param str val: The value for the option.
        """
        pulumi.set(__self__, "field", field)
        if val is not None:
            pulumi.set(__self__, "val", val)

    @property
    @pulumi.getter
    def field(self) -> str:
        """
        The name of the option you want to set.
        """
        return pulumi.get(self, "field")

    @property
    @pulumi.getter
    def val(self) -> Optional[str]:
        """
        The value for the option.
        """
        return pulumi.get(self, "val")


@pulumi.output_type
class IndexObjName(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "databaseName":
            suggest = "database_name"
        elif key == "schemaName":
            suggest = "schema_name"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in IndexObjName. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        IndexObjName.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        IndexObjName.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 name: str,
                 database_name: Optional[str] = None,
                 schema_name: Optional[str] = None):
        """
        :param str name: The obj_name name.
        :param str database_name: The obj_name database name.
        :param str schema_name: The obj_name schema name.
        """
        pulumi.set(__self__, "name", name)
        if database_name is not None:
            pulumi.set(__self__, "database_name", database_name)
        if schema_name is not None:
            pulumi.set(__self__, "schema_name", schema_name)

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        The obj_name name.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter(name="databaseName")
    def database_name(self) -> Optional[str]:
        """
        The obj_name database name.
        """
        return pulumi.get(self, "database_name")

    @property
    @pulumi.getter(name="schemaName")
    def schema_name(self) -> Optional[str]:
        """
        The obj_name schema name.
        """
        return pulumi.get(self, "schema_name")


@pulumi.output_type
class SinkKafkaEnvelope(dict):
    def __init__(__self__, *,
                 debezium: Optional[bool] = None,
                 upsert: Optional[bool] = None):
        """
        :param bool debezium: The generated schemas have a Debezium-style diff envelope to capture changes in the input view or source.
        :param bool upsert: The sink emits data with upsert semantics: updates and inserts for the given key are expressed as a value, and deletes are expressed as a null value payload in Kafka.
        """
        if debezium is not None:
            pulumi.set(__self__, "debezium", debezium)
        if upsert is not None:
            pulumi.set(__self__, "upsert", upsert)

    @property
    @pulumi.getter
    def debezium(self) -> Optional[bool]:
        """
        The generated schemas have a Debezium-style diff envelope to capture changes in the input view or source.
        """
        return pulumi.get(self, "debezium")

    @property
    @pulumi.getter
    def upsert(self) -> Optional[bool]:
        """
        The sink emits data with upsert semantics: updates and inserts for the given key are expressed as a value, and deletes are expressed as a null value payload in Kafka.
        """
        return pulumi.get(self, "upsert")


@pulumi.output_type
class SinkKafkaFormat(dict):
    def __init__(__self__, *,
                 avro: Optional['outputs.SinkKafkaFormatAvro'] = None,
                 json: Optional[bool] = None):
        """
        :param 'SinkKafkaFormatAvroArgs' avro: Avro format.
        :param bool json: JSON format.
        """
        if avro is not None:
            pulumi.set(__self__, "avro", avro)
        if json is not None:
            pulumi.set(__self__, "json", json)

    @property
    @pulumi.getter
    def avro(self) -> Optional['outputs.SinkKafkaFormatAvro']:
        """
        Avro format.
        """
        return pulumi.get(self, "avro")

    @property
    @pulumi.getter
    def json(self) -> Optional[bool]:
        """
        JSON format.
        """
        return pulumi.get(self, "json")


@pulumi.output_type
class SinkKafkaFormatAvro(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "schemaRegistryConnection":
            suggest = "schema_registry_connection"
        elif key == "avroKeyFullname":
            suggest = "avro_key_fullname"
        elif key == "avroValueFullname":
            suggest = "avro_value_fullname"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in SinkKafkaFormatAvro. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        SinkKafkaFormatAvro.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        SinkKafkaFormatAvro.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 schema_registry_connection: 'outputs.SinkKafkaFormatAvroSchemaRegistryConnection',
                 avro_key_fullname: Optional[str] = None,
                 avro_value_fullname: Optional[str] = None):
        pulumi.set(__self__, "schema_registry_connection", schema_registry_connection)
        if avro_key_fullname is not None:
            pulumi.set(__self__, "avro_key_fullname", avro_key_fullname)
        if avro_value_fullname is not None:
            pulumi.set(__self__, "avro_value_fullname", avro_value_fullname)

    @property
    @pulumi.getter(name="schemaRegistryConnection")
    def schema_registry_connection(self) -> 'outputs.SinkKafkaFormatAvroSchemaRegistryConnection':
        return pulumi.get(self, "schema_registry_connection")

    @property
    @pulumi.getter(name="avroKeyFullname")
    def avro_key_fullname(self) -> Optional[str]:
        return pulumi.get(self, "avro_key_fullname")

    @property
    @pulumi.getter(name="avroValueFullname")
    def avro_value_fullname(self) -> Optional[str]:
        return pulumi.get(self, "avro_value_fullname")


@pulumi.output_type
class SinkKafkaFormatAvroSchemaRegistryConnection(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "databaseName":
            suggest = "database_name"
        elif key == "schemaName":
            suggest = "schema_name"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in SinkKafkaFormatAvroSchemaRegistryConnection. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        SinkKafkaFormatAvroSchemaRegistryConnection.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        SinkKafkaFormatAvroSchemaRegistryConnection.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 name: str,
                 database_name: Optional[str] = None,
                 schema_name: Optional[str] = None):
        """
        :param str name: The identifier for the sink.
        :param str database_name: The identifier for the sink database.
        :param str schema_name: The identifier for the sink schema.
        """
        pulumi.set(__self__, "name", name)
        if database_name is not None:
            pulumi.set(__self__, "database_name", database_name)
        if schema_name is not None:
            pulumi.set(__self__, "schema_name", schema_name)

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        The identifier for the sink.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter(name="databaseName")
    def database_name(self) -> Optional[str]:
        """
        The identifier for the sink database.
        """
        return pulumi.get(self, "database_name")

    @property
    @pulumi.getter(name="schemaName")
    def schema_name(self) -> Optional[str]:
        """
        The identifier for the sink schema.
        """
        return pulumi.get(self, "schema_name")


@pulumi.output_type
class SinkKafkaFrom(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "databaseName":
            suggest = "database_name"
        elif key == "schemaName":
            suggest = "schema_name"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in SinkKafkaFrom. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        SinkKafkaFrom.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        SinkKafkaFrom.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 name: str,
                 database_name: Optional[str] = None,
                 schema_name: Optional[str] = None):
        """
        :param str name: The from name.
        :param str database_name: The from database name.
        :param str schema_name: The from schema name.
        """
        pulumi.set(__self__, "name", name)
        if database_name is not None:
            pulumi.set(__self__, "database_name", database_name)
        if schema_name is not None:
            pulumi.set(__self__, "schema_name", schema_name)

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        The from name.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter(name="databaseName")
    def database_name(self) -> Optional[str]:
        """
        The from database name.
        """
        return pulumi.get(self, "database_name")

    @property
    @pulumi.getter(name="schemaName")
    def schema_name(self) -> Optional[str]:
        """
        The from schema name.
        """
        return pulumi.get(self, "schema_name")


@pulumi.output_type
class SinkKafkaKafkaConnection(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "databaseName":
            suggest = "database_name"
        elif key == "schemaName":
            suggest = "schema_name"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in SinkKafkaKafkaConnection. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        SinkKafkaKafkaConnection.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        SinkKafkaKafkaConnection.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 name: str,
                 database_name: Optional[str] = None,
                 schema_name: Optional[str] = None):
        """
        :param str name: The kafka_connection name.
        :param str database_name: The kafka_connection database name.
        :param str schema_name: The kafka_connection schema name.
        """
        pulumi.set(__self__, "name", name)
        if database_name is not None:
            pulumi.set(__self__, "database_name", database_name)
        if schema_name is not None:
            pulumi.set(__self__, "schema_name", schema_name)

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        The kafka_connection name.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter(name="databaseName")
    def database_name(self) -> Optional[str]:
        """
        The kafka_connection database name.
        """
        return pulumi.get(self, "database_name")

    @property
    @pulumi.getter(name="schemaName")
    def schema_name(self) -> Optional[str]:
        """
        The kafka_connection schema name.
        """
        return pulumi.get(self, "schema_name")


@pulumi.output_type
class SourceKafkaEnvelope(dict):
    def __init__(__self__, *,
                 debezium: Optional[bool] = None,
                 none: Optional[bool] = None,
                 upsert: Optional[bool] = None):
        """
        :param bool debezium: Use the Debezium envelope, which uses a diff envelope to handle CRUD operations.
        :param bool none: Use an append-only envelope. This means that records will only be appended and cannot be updated or deleted.
        :param bool upsert: Use the upsert envelope, which uses message keys to handle CRUD operations.
        """
        if debezium is not None:
            pulumi.set(__self__, "debezium", debezium)
        if none is not None:
            pulumi.set(__self__, "none", none)
        if upsert is not None:
            pulumi.set(__self__, "upsert", upsert)

    @property
    @pulumi.getter
    def debezium(self) -> Optional[bool]:
        """
        Use the Debezium envelope, which uses a diff envelope to handle CRUD operations.
        """
        return pulumi.get(self, "debezium")

    @property
    @pulumi.getter
    def none(self) -> Optional[bool]:
        """
        Use an append-only envelope. This means that records will only be appended and cannot be updated or deleted.
        """
        return pulumi.get(self, "none")

    @property
    @pulumi.getter
    def upsert(self) -> Optional[bool]:
        """
        Use the upsert envelope, which uses message keys to handle CRUD operations.
        """
        return pulumi.get(self, "upsert")


@pulumi.output_type
class SourceKafkaFormat(dict):
    def __init__(__self__, *,
                 avro: Optional['outputs.SourceKafkaFormatAvro'] = None,
                 csvs: Optional[Sequence['outputs.SourceKafkaFormatCsv']] = None,
                 json: Optional[bool] = None,
                 protobuf: Optional['outputs.SourceKafkaFormatProtobuf'] = None,
                 text: Optional[bool] = None):
        """
        :param 'SourceKafkaFormatAvroArgs' avro: Avro format.
        :param Sequence['SourceKafkaFormatCsvArgs'] csvs: CSV format.
        :param bool json: JSON format.
        :param 'SourceKafkaFormatProtobufArgs' protobuf: Protobuf format.
        :param bool text: Text format.
        """
        if avro is not None:
            pulumi.set(__self__, "avro", avro)
        if csvs is not None:
            pulumi.set(__self__, "csvs", csvs)
        if json is not None:
            pulumi.set(__self__, "json", json)
        if protobuf is not None:
            pulumi.set(__self__, "protobuf", protobuf)
        if text is not None:
            pulumi.set(__self__, "text", text)

    @property
    @pulumi.getter
    def avro(self) -> Optional['outputs.SourceKafkaFormatAvro']:
        """
        Avro format.
        """
        return pulumi.get(self, "avro")

    @property
    @pulumi.getter
    def csvs(self) -> Optional[Sequence['outputs.SourceKafkaFormatCsv']]:
        """
        CSV format.
        """
        return pulumi.get(self, "csvs")

    @property
    @pulumi.getter
    def json(self) -> Optional[bool]:
        """
        JSON format.
        """
        return pulumi.get(self, "json")

    @property
    @pulumi.getter
    def protobuf(self) -> Optional['outputs.SourceKafkaFormatProtobuf']:
        """
        Protobuf format.
        """
        return pulumi.get(self, "protobuf")

    @property
    @pulumi.getter
    def text(self) -> Optional[bool]:
        """
        Text format.
        """
        return pulumi.get(self, "text")


@pulumi.output_type
class SourceKafkaFormatAvro(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "schemaRegistryConnection":
            suggest = "schema_registry_connection"
        elif key == "keyStrategy":
            suggest = "key_strategy"
        elif key == "valueStrategy":
            suggest = "value_strategy"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in SourceKafkaFormatAvro. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        SourceKafkaFormatAvro.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        SourceKafkaFormatAvro.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 schema_registry_connection: 'outputs.SourceKafkaFormatAvroSchemaRegistryConnection',
                 key_strategy: Optional[str] = None,
                 value_strategy: Optional[str] = None):
        pulumi.set(__self__, "schema_registry_connection", schema_registry_connection)
        if key_strategy is not None:
            pulumi.set(__self__, "key_strategy", key_strategy)
        if value_strategy is not None:
            pulumi.set(__self__, "value_strategy", value_strategy)

    @property
    @pulumi.getter(name="schemaRegistryConnection")
    def schema_registry_connection(self) -> 'outputs.SourceKafkaFormatAvroSchemaRegistryConnection':
        return pulumi.get(self, "schema_registry_connection")

    @property
    @pulumi.getter(name="keyStrategy")
    def key_strategy(self) -> Optional[str]:
        return pulumi.get(self, "key_strategy")

    @property
    @pulumi.getter(name="valueStrategy")
    def value_strategy(self) -> Optional[str]:
        return pulumi.get(self, "value_strategy")


@pulumi.output_type
class SourceKafkaFormatAvroSchemaRegistryConnection(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "databaseName":
            suggest = "database_name"
        elif key == "schemaName":
            suggest = "schema_name"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in SourceKafkaFormatAvroSchemaRegistryConnection. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        SourceKafkaFormatAvroSchemaRegistryConnection.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        SourceKafkaFormatAvroSchemaRegistryConnection.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 name: str,
                 database_name: Optional[str] = None,
                 schema_name: Optional[str] = None):
        """
        :param str name: The identifier for the source.
        :param str database_name: The identifier for the source database.
        :param str schema_name: The identifier for the source schema.
        """
        pulumi.set(__self__, "name", name)
        if database_name is not None:
            pulumi.set(__self__, "database_name", database_name)
        if schema_name is not None:
            pulumi.set(__self__, "schema_name", schema_name)

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        The identifier for the source.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter(name="databaseName")
    def database_name(self) -> Optional[str]:
        """
        The identifier for the source database.
        """
        return pulumi.get(self, "database_name")

    @property
    @pulumi.getter(name="schemaName")
    def schema_name(self) -> Optional[str]:
        """
        The identifier for the source schema.
        """
        return pulumi.get(self, "schema_name")


@pulumi.output_type
class SourceKafkaFormatCsv(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "delimitedBy":
            suggest = "delimited_by"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in SourceKafkaFormatCsv. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        SourceKafkaFormatCsv.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        SourceKafkaFormatCsv.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 column: Optional[int] = None,
                 delimited_by: Optional[str] = None,
                 headers: Optional[Sequence[str]] = None):
        if column is not None:
            pulumi.set(__self__, "column", column)
        if delimited_by is not None:
            pulumi.set(__self__, "delimited_by", delimited_by)
        if headers is not None:
            pulumi.set(__self__, "headers", headers)

    @property
    @pulumi.getter
    def column(self) -> Optional[int]:
        return pulumi.get(self, "column")

    @property
    @pulumi.getter(name="delimitedBy")
    def delimited_by(self) -> Optional[str]:
        return pulumi.get(self, "delimited_by")

    @property
    @pulumi.getter
    def headers(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "headers")


@pulumi.output_type
class SourceKafkaFormatProtobuf(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "schemaRegistryConnection":
            suggest = "schema_registry_connection"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in SourceKafkaFormatProtobuf. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        SourceKafkaFormatProtobuf.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        SourceKafkaFormatProtobuf.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 message: str,
                 schema_registry_connection: 'outputs.SourceKafkaFormatProtobufSchemaRegistryConnection'):
        pulumi.set(__self__, "message", message)
        pulumi.set(__self__, "schema_registry_connection", schema_registry_connection)

    @property
    @pulumi.getter
    def message(self) -> str:
        return pulumi.get(self, "message")

    @property
    @pulumi.getter(name="schemaRegistryConnection")
    def schema_registry_connection(self) -> 'outputs.SourceKafkaFormatProtobufSchemaRegistryConnection':
        return pulumi.get(self, "schema_registry_connection")


@pulumi.output_type
class SourceKafkaFormatProtobufSchemaRegistryConnection(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "databaseName":
            suggest = "database_name"
        elif key == "schemaName":
            suggest = "schema_name"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in SourceKafkaFormatProtobufSchemaRegistryConnection. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        SourceKafkaFormatProtobufSchemaRegistryConnection.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        SourceKafkaFormatProtobufSchemaRegistryConnection.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 name: str,
                 database_name: Optional[str] = None,
                 schema_name: Optional[str] = None):
        """
        :param str name: The identifier for the source.
        :param str database_name: The identifier for the source database.
        :param str schema_name: The identifier for the source schema.
        """
        pulumi.set(__self__, "name", name)
        if database_name is not None:
            pulumi.set(__self__, "database_name", database_name)
        if schema_name is not None:
            pulumi.set(__self__, "schema_name", schema_name)

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        The identifier for the source.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter(name="databaseName")
    def database_name(self) -> Optional[str]:
        """
        The identifier for the source database.
        """
        return pulumi.get(self, "database_name")

    @property
    @pulumi.getter(name="schemaName")
    def schema_name(self) -> Optional[str]:
        """
        The identifier for the source schema.
        """
        return pulumi.get(self, "schema_name")


@pulumi.output_type
class SourceKafkaKafkaConnection(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "databaseName":
            suggest = "database_name"
        elif key == "schemaName":
            suggest = "schema_name"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in SourceKafkaKafkaConnection. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        SourceKafkaKafkaConnection.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        SourceKafkaKafkaConnection.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 name: str,
                 database_name: Optional[str] = None,
                 schema_name: Optional[str] = None):
        """
        :param str name: The kafka_connection name.
        :param str database_name: The kafka_connection database name.
        :param str schema_name: The kafka_connection schema name.
        """
        pulumi.set(__self__, "name", name)
        if database_name is not None:
            pulumi.set(__self__, "database_name", database_name)
        if schema_name is not None:
            pulumi.set(__self__, "schema_name", schema_name)

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        The kafka_connection name.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter(name="databaseName")
    def database_name(self) -> Optional[str]:
        """
        The kafka_connection database name.
        """
        return pulumi.get(self, "database_name")

    @property
    @pulumi.getter(name="schemaName")
    def schema_name(self) -> Optional[str]:
        """
        The kafka_connection schema name.
        """
        return pulumi.get(self, "schema_name")


@pulumi.output_type
class SourceKafkaKeyFormat(dict):
    def __init__(__self__, *,
                 avro: Optional['outputs.SourceKafkaKeyFormatAvro'] = None,
                 csvs: Optional[Sequence['outputs.SourceKafkaKeyFormatCsv']] = None,
                 json: Optional[bool] = None,
                 protobuf: Optional['outputs.SourceKafkaKeyFormatProtobuf'] = None,
                 text: Optional[bool] = None):
        """
        :param 'SourceKafkaKeyFormatAvroArgs' avro: Avro format.
        :param Sequence['SourceKafkaKeyFormatCsvArgs'] csvs: CSV format.
        :param bool json: JSON format.
        :param 'SourceKafkaKeyFormatProtobufArgs' protobuf: Protobuf format.
        :param bool text: Text format.
        """
        if avro is not None:
            pulumi.set(__self__, "avro", avro)
        if csvs is not None:
            pulumi.set(__self__, "csvs", csvs)
        if json is not None:
            pulumi.set(__self__, "json", json)
        if protobuf is not None:
            pulumi.set(__self__, "protobuf", protobuf)
        if text is not None:
            pulumi.set(__self__, "text", text)

    @property
    @pulumi.getter
    def avro(self) -> Optional['outputs.SourceKafkaKeyFormatAvro']:
        """
        Avro format.
        """
        return pulumi.get(self, "avro")

    @property
    @pulumi.getter
    def csvs(self) -> Optional[Sequence['outputs.SourceKafkaKeyFormatCsv']]:
        """
        CSV format.
        """
        return pulumi.get(self, "csvs")

    @property
    @pulumi.getter
    def json(self) -> Optional[bool]:
        """
        JSON format.
        """
        return pulumi.get(self, "json")

    @property
    @pulumi.getter
    def protobuf(self) -> Optional['outputs.SourceKafkaKeyFormatProtobuf']:
        """
        Protobuf format.
        """
        return pulumi.get(self, "protobuf")

    @property
    @pulumi.getter
    def text(self) -> Optional[bool]:
        """
        Text format.
        """
        return pulumi.get(self, "text")


@pulumi.output_type
class SourceKafkaKeyFormatAvro(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "schemaRegistryConnection":
            suggest = "schema_registry_connection"
        elif key == "keyStrategy":
            suggest = "key_strategy"
        elif key == "valueStrategy":
            suggest = "value_strategy"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in SourceKafkaKeyFormatAvro. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        SourceKafkaKeyFormatAvro.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        SourceKafkaKeyFormatAvro.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 schema_registry_connection: 'outputs.SourceKafkaKeyFormatAvroSchemaRegistryConnection',
                 key_strategy: Optional[str] = None,
                 value_strategy: Optional[str] = None):
        pulumi.set(__self__, "schema_registry_connection", schema_registry_connection)
        if key_strategy is not None:
            pulumi.set(__self__, "key_strategy", key_strategy)
        if value_strategy is not None:
            pulumi.set(__self__, "value_strategy", value_strategy)

    @property
    @pulumi.getter(name="schemaRegistryConnection")
    def schema_registry_connection(self) -> 'outputs.SourceKafkaKeyFormatAvroSchemaRegistryConnection':
        return pulumi.get(self, "schema_registry_connection")

    @property
    @pulumi.getter(name="keyStrategy")
    def key_strategy(self) -> Optional[str]:
        return pulumi.get(self, "key_strategy")

    @property
    @pulumi.getter(name="valueStrategy")
    def value_strategy(self) -> Optional[str]:
        return pulumi.get(self, "value_strategy")


@pulumi.output_type
class SourceKafkaKeyFormatAvroSchemaRegistryConnection(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "databaseName":
            suggest = "database_name"
        elif key == "schemaName":
            suggest = "schema_name"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in SourceKafkaKeyFormatAvroSchemaRegistryConnection. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        SourceKafkaKeyFormatAvroSchemaRegistryConnection.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        SourceKafkaKeyFormatAvroSchemaRegistryConnection.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 name: str,
                 database_name: Optional[str] = None,
                 schema_name: Optional[str] = None):
        """
        :param str name: The identifier for the source.
        :param str database_name: The identifier for the source database.
        :param str schema_name: The identifier for the source schema.
        """
        pulumi.set(__self__, "name", name)
        if database_name is not None:
            pulumi.set(__self__, "database_name", database_name)
        if schema_name is not None:
            pulumi.set(__self__, "schema_name", schema_name)

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        The identifier for the source.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter(name="databaseName")
    def database_name(self) -> Optional[str]:
        """
        The identifier for the source database.
        """
        return pulumi.get(self, "database_name")

    @property
    @pulumi.getter(name="schemaName")
    def schema_name(self) -> Optional[str]:
        """
        The identifier for the source schema.
        """
        return pulumi.get(self, "schema_name")


@pulumi.output_type
class SourceKafkaKeyFormatCsv(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "delimitedBy":
            suggest = "delimited_by"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in SourceKafkaKeyFormatCsv. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        SourceKafkaKeyFormatCsv.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        SourceKafkaKeyFormatCsv.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 column: Optional[int] = None,
                 delimited_by: Optional[str] = None,
                 headers: Optional[Sequence[str]] = None):
        if column is not None:
            pulumi.set(__self__, "column", column)
        if delimited_by is not None:
            pulumi.set(__self__, "delimited_by", delimited_by)
        if headers is not None:
            pulumi.set(__self__, "headers", headers)

    @property
    @pulumi.getter
    def column(self) -> Optional[int]:
        return pulumi.get(self, "column")

    @property
    @pulumi.getter(name="delimitedBy")
    def delimited_by(self) -> Optional[str]:
        return pulumi.get(self, "delimited_by")

    @property
    @pulumi.getter
    def headers(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "headers")


@pulumi.output_type
class SourceKafkaKeyFormatProtobuf(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "schemaRegistryConnection":
            suggest = "schema_registry_connection"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in SourceKafkaKeyFormatProtobuf. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        SourceKafkaKeyFormatProtobuf.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        SourceKafkaKeyFormatProtobuf.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 message: str,
                 schema_registry_connection: 'outputs.SourceKafkaKeyFormatProtobufSchemaRegistryConnection'):
        pulumi.set(__self__, "message", message)
        pulumi.set(__self__, "schema_registry_connection", schema_registry_connection)

    @property
    @pulumi.getter
    def message(self) -> str:
        return pulumi.get(self, "message")

    @property
    @pulumi.getter(name="schemaRegistryConnection")
    def schema_registry_connection(self) -> 'outputs.SourceKafkaKeyFormatProtobufSchemaRegistryConnection':
        return pulumi.get(self, "schema_registry_connection")


@pulumi.output_type
class SourceKafkaKeyFormatProtobufSchemaRegistryConnection(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "databaseName":
            suggest = "database_name"
        elif key == "schemaName":
            suggest = "schema_name"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in SourceKafkaKeyFormatProtobufSchemaRegistryConnection. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        SourceKafkaKeyFormatProtobufSchemaRegistryConnection.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        SourceKafkaKeyFormatProtobufSchemaRegistryConnection.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 name: str,
                 database_name: Optional[str] = None,
                 schema_name: Optional[str] = None):
        """
        :param str name: The identifier for the source.
        :param str database_name: The identifier for the source database.
        :param str schema_name: The identifier for the source schema.
        """
        pulumi.set(__self__, "name", name)
        if database_name is not None:
            pulumi.set(__self__, "database_name", database_name)
        if schema_name is not None:
            pulumi.set(__self__, "schema_name", schema_name)

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        The identifier for the source.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter(name="databaseName")
    def database_name(self) -> Optional[str]:
        """
        The identifier for the source database.
        """
        return pulumi.get(self, "database_name")

    @property
    @pulumi.getter(name="schemaName")
    def schema_name(self) -> Optional[str]:
        """
        The identifier for the source schema.
        """
        return pulumi.get(self, "schema_name")


@pulumi.output_type
class SourceKafkaValueFormat(dict):
    def __init__(__self__, *,
                 avro: Optional['outputs.SourceKafkaValueFormatAvro'] = None,
                 csvs: Optional[Sequence['outputs.SourceKafkaValueFormatCsv']] = None,
                 json: Optional[bool] = None,
                 protobuf: Optional['outputs.SourceKafkaValueFormatProtobuf'] = None,
                 text: Optional[bool] = None):
        """
        :param 'SourceKafkaValueFormatAvroArgs' avro: Avro format.
        :param Sequence['SourceKafkaValueFormatCsvArgs'] csvs: CSV format.
        :param bool json: JSON format.
        :param 'SourceKafkaValueFormatProtobufArgs' protobuf: Protobuf format.
        :param bool text: Text format.
        """
        if avro is not None:
            pulumi.set(__self__, "avro", avro)
        if csvs is not None:
            pulumi.set(__self__, "csvs", csvs)
        if json is not None:
            pulumi.set(__self__, "json", json)
        if protobuf is not None:
            pulumi.set(__self__, "protobuf", protobuf)
        if text is not None:
            pulumi.set(__self__, "text", text)

    @property
    @pulumi.getter
    def avro(self) -> Optional['outputs.SourceKafkaValueFormatAvro']:
        """
        Avro format.
        """
        return pulumi.get(self, "avro")

    @property
    @pulumi.getter
    def csvs(self) -> Optional[Sequence['outputs.SourceKafkaValueFormatCsv']]:
        """
        CSV format.
        """
        return pulumi.get(self, "csvs")

    @property
    @pulumi.getter
    def json(self) -> Optional[bool]:
        """
        JSON format.
        """
        return pulumi.get(self, "json")

    @property
    @pulumi.getter
    def protobuf(self) -> Optional['outputs.SourceKafkaValueFormatProtobuf']:
        """
        Protobuf format.
        """
        return pulumi.get(self, "protobuf")

    @property
    @pulumi.getter
    def text(self) -> Optional[bool]:
        """
        Text format.
        """
        return pulumi.get(self, "text")


@pulumi.output_type
class SourceKafkaValueFormatAvro(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "schemaRegistryConnection":
            suggest = "schema_registry_connection"
        elif key == "keyStrategy":
            suggest = "key_strategy"
        elif key == "valueStrategy":
            suggest = "value_strategy"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in SourceKafkaValueFormatAvro. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        SourceKafkaValueFormatAvro.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        SourceKafkaValueFormatAvro.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 schema_registry_connection: 'outputs.SourceKafkaValueFormatAvroSchemaRegistryConnection',
                 key_strategy: Optional[str] = None,
                 value_strategy: Optional[str] = None):
        pulumi.set(__self__, "schema_registry_connection", schema_registry_connection)
        if key_strategy is not None:
            pulumi.set(__self__, "key_strategy", key_strategy)
        if value_strategy is not None:
            pulumi.set(__self__, "value_strategy", value_strategy)

    @property
    @pulumi.getter(name="schemaRegistryConnection")
    def schema_registry_connection(self) -> 'outputs.SourceKafkaValueFormatAvroSchemaRegistryConnection':
        return pulumi.get(self, "schema_registry_connection")

    @property
    @pulumi.getter(name="keyStrategy")
    def key_strategy(self) -> Optional[str]:
        return pulumi.get(self, "key_strategy")

    @property
    @pulumi.getter(name="valueStrategy")
    def value_strategy(self) -> Optional[str]:
        return pulumi.get(self, "value_strategy")


@pulumi.output_type
class SourceKafkaValueFormatAvroSchemaRegistryConnection(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "databaseName":
            suggest = "database_name"
        elif key == "schemaName":
            suggest = "schema_name"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in SourceKafkaValueFormatAvroSchemaRegistryConnection. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        SourceKafkaValueFormatAvroSchemaRegistryConnection.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        SourceKafkaValueFormatAvroSchemaRegistryConnection.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 name: str,
                 database_name: Optional[str] = None,
                 schema_name: Optional[str] = None):
        """
        :param str name: The identifier for the source.
        :param str database_name: The identifier for the source database.
        :param str schema_name: The identifier for the source schema.
        """
        pulumi.set(__self__, "name", name)
        if database_name is not None:
            pulumi.set(__self__, "database_name", database_name)
        if schema_name is not None:
            pulumi.set(__self__, "schema_name", schema_name)

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        The identifier for the source.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter(name="databaseName")
    def database_name(self) -> Optional[str]:
        """
        The identifier for the source database.
        """
        return pulumi.get(self, "database_name")

    @property
    @pulumi.getter(name="schemaName")
    def schema_name(self) -> Optional[str]:
        """
        The identifier for the source schema.
        """
        return pulumi.get(self, "schema_name")


@pulumi.output_type
class SourceKafkaValueFormatCsv(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "delimitedBy":
            suggest = "delimited_by"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in SourceKafkaValueFormatCsv. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        SourceKafkaValueFormatCsv.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        SourceKafkaValueFormatCsv.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 column: Optional[int] = None,
                 delimited_by: Optional[str] = None,
                 headers: Optional[Sequence[str]] = None):
        if column is not None:
            pulumi.set(__self__, "column", column)
        if delimited_by is not None:
            pulumi.set(__self__, "delimited_by", delimited_by)
        if headers is not None:
            pulumi.set(__self__, "headers", headers)

    @property
    @pulumi.getter
    def column(self) -> Optional[int]:
        return pulumi.get(self, "column")

    @property
    @pulumi.getter(name="delimitedBy")
    def delimited_by(self) -> Optional[str]:
        return pulumi.get(self, "delimited_by")

    @property
    @pulumi.getter
    def headers(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "headers")


@pulumi.output_type
class SourceKafkaValueFormatProtobuf(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "schemaRegistryConnection":
            suggest = "schema_registry_connection"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in SourceKafkaValueFormatProtobuf. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        SourceKafkaValueFormatProtobuf.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        SourceKafkaValueFormatProtobuf.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 message: str,
                 schema_registry_connection: 'outputs.SourceKafkaValueFormatProtobufSchemaRegistryConnection'):
        pulumi.set(__self__, "message", message)
        pulumi.set(__self__, "schema_registry_connection", schema_registry_connection)

    @property
    @pulumi.getter
    def message(self) -> str:
        return pulumi.get(self, "message")

    @property
    @pulumi.getter(name="schemaRegistryConnection")
    def schema_registry_connection(self) -> 'outputs.SourceKafkaValueFormatProtobufSchemaRegistryConnection':
        return pulumi.get(self, "schema_registry_connection")


@pulumi.output_type
class SourceKafkaValueFormatProtobufSchemaRegistryConnection(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "databaseName":
            suggest = "database_name"
        elif key == "schemaName":
            suggest = "schema_name"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in SourceKafkaValueFormatProtobufSchemaRegistryConnection. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        SourceKafkaValueFormatProtobufSchemaRegistryConnection.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        SourceKafkaValueFormatProtobufSchemaRegistryConnection.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 name: str,
                 database_name: Optional[str] = None,
                 schema_name: Optional[str] = None):
        """
        :param str name: The identifier for the source.
        :param str database_name: The identifier for the source database.
        :param str schema_name: The identifier for the source schema.
        """
        pulumi.set(__self__, "name", name)
        if database_name is not None:
            pulumi.set(__self__, "database_name", database_name)
        if schema_name is not None:
            pulumi.set(__self__, "schema_name", schema_name)

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        The identifier for the source.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter(name="databaseName")
    def database_name(self) -> Optional[str]:
        """
        The identifier for the source database.
        """
        return pulumi.get(self, "database_name")

    @property
    @pulumi.getter(name="schemaName")
    def schema_name(self) -> Optional[str]:
        """
        The identifier for the source schema.
        """
        return pulumi.get(self, "schema_name")


@pulumi.output_type
class SourceLoadgenAuctionOption(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "scaleFactor":
            suggest = "scale_factor"
        elif key == "tickInterval":
            suggest = "tick_interval"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in SourceLoadgenAuctionOption. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        SourceLoadgenAuctionOption.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        SourceLoadgenAuctionOption.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 scale_factor: Optional[float] = None,
                 tables: Optional[Sequence['outputs.SourceLoadgenAuctionOptionTable']] = None,
                 tick_interval: Optional[str] = None):
        """
        :param float scale_factor: The scale factor for the generator. Defaults to 0.01 (~ 10MB).
        :param Sequence['SourceLoadgenAuctionOptionTableArgs'] tables: Creates subsources for specific tables.
        :param str tick_interval: The interval at which the next datum should be emitted. Defaults to one second.
        """
        if scale_factor is not None:
            pulumi.set(__self__, "scale_factor", scale_factor)
        if tables is not None:
            pulumi.set(__self__, "tables", tables)
        if tick_interval is not None:
            pulumi.set(__self__, "tick_interval", tick_interval)

    @property
    @pulumi.getter(name="scaleFactor")
    def scale_factor(self) -> Optional[float]:
        """
        The scale factor for the generator. Defaults to 0.01 (~ 10MB).
        """
        return pulumi.get(self, "scale_factor")

    @property
    @pulumi.getter
    def tables(self) -> Optional[Sequence['outputs.SourceLoadgenAuctionOptionTable']]:
        """
        Creates subsources for specific tables.
        """
        return pulumi.get(self, "tables")

    @property
    @pulumi.getter(name="tickInterval")
    def tick_interval(self) -> Optional[str]:
        """
        The interval at which the next datum should be emitted. Defaults to one second.
        """
        return pulumi.get(self, "tick_interval")


@pulumi.output_type
class SourceLoadgenAuctionOptionTable(dict):
    def __init__(__self__, *,
                 name: str,
                 alias: Optional[str] = None):
        """
        :param str name: The identifier for the source.
        """
        pulumi.set(__self__, "name", name)
        if alias is not None:
            pulumi.set(__self__, "alias", alias)

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        The identifier for the source.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def alias(self) -> Optional[str]:
        return pulumi.get(self, "alias")


@pulumi.output_type
class SourceLoadgenCounterOption(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "maxCardinality":
            suggest = "max_cardinality"
        elif key == "scaleFactor":
            suggest = "scale_factor"
        elif key == "tickInterval":
            suggest = "tick_interval"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in SourceLoadgenCounterOption. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        SourceLoadgenCounterOption.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        SourceLoadgenCounterOption.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 max_cardinality: Optional[int] = None,
                 scale_factor: Optional[float] = None,
                 tick_interval: Optional[str] = None):
        """
        :param int max_cardinality: Causes the generator to delete old values to keep the collection at most a given size. Defaults to unlimited.
        :param float scale_factor: The scale factor for the generator. Defaults to 0.01 (~ 10MB).
        :param str tick_interval: The interval at which the next datum should be emitted. Defaults to one second.
        """
        if max_cardinality is not None:
            pulumi.set(__self__, "max_cardinality", max_cardinality)
        if scale_factor is not None:
            pulumi.set(__self__, "scale_factor", scale_factor)
        if tick_interval is not None:
            pulumi.set(__self__, "tick_interval", tick_interval)

    @property
    @pulumi.getter(name="maxCardinality")
    def max_cardinality(self) -> Optional[int]:
        """
        Causes the generator to delete old values to keep the collection at most a given size. Defaults to unlimited.
        """
        return pulumi.get(self, "max_cardinality")

    @property
    @pulumi.getter(name="scaleFactor")
    def scale_factor(self) -> Optional[float]:
        """
        The scale factor for the generator. Defaults to 0.01 (~ 10MB).
        """
        return pulumi.get(self, "scale_factor")

    @property
    @pulumi.getter(name="tickInterval")
    def tick_interval(self) -> Optional[str]:
        """
        The interval at which the next datum should be emitted. Defaults to one second.
        """
        return pulumi.get(self, "tick_interval")


@pulumi.output_type
class SourceLoadgenTpchOption(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "scaleFactor":
            suggest = "scale_factor"
        elif key == "tickInterval":
            suggest = "tick_interval"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in SourceLoadgenTpchOption. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        SourceLoadgenTpchOption.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        SourceLoadgenTpchOption.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 scale_factor: Optional[float] = None,
                 tables: Optional[Sequence['outputs.SourceLoadgenTpchOptionTable']] = None,
                 tick_interval: Optional[str] = None):
        """
        :param float scale_factor: The scale factor for the generator. Defaults to 0.01 (~ 10MB).
        :param Sequence['SourceLoadgenTpchOptionTableArgs'] tables: Creates subsources for specific tables.
        :param str tick_interval: The interval at which the next datum should be emitted. Defaults to one second.
        """
        if scale_factor is not None:
            pulumi.set(__self__, "scale_factor", scale_factor)
        if tables is not None:
            pulumi.set(__self__, "tables", tables)
        if tick_interval is not None:
            pulumi.set(__self__, "tick_interval", tick_interval)

    @property
    @pulumi.getter(name="scaleFactor")
    def scale_factor(self) -> Optional[float]:
        """
        The scale factor for the generator. Defaults to 0.01 (~ 10MB).
        """
        return pulumi.get(self, "scale_factor")

    @property
    @pulumi.getter
    def tables(self) -> Optional[Sequence['outputs.SourceLoadgenTpchOptionTable']]:
        """
        Creates subsources for specific tables.
        """
        return pulumi.get(self, "tables")

    @property
    @pulumi.getter(name="tickInterval")
    def tick_interval(self) -> Optional[str]:
        """
        The interval at which the next datum should be emitted. Defaults to one second.
        """
        return pulumi.get(self, "tick_interval")


@pulumi.output_type
class SourceLoadgenTpchOptionTable(dict):
    def __init__(__self__, *,
                 name: str,
                 alias: Optional[str] = None):
        """
        :param str name: The identifier for the source.
        """
        pulumi.set(__self__, "name", name)
        if alias is not None:
            pulumi.set(__self__, "alias", alias)

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        The identifier for the source.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def alias(self) -> Optional[str]:
        return pulumi.get(self, "alias")


@pulumi.output_type
class SourcePostgresPostgresConnection(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "databaseName":
            suggest = "database_name"
        elif key == "schemaName":
            suggest = "schema_name"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in SourcePostgresPostgresConnection. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        SourcePostgresPostgresConnection.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        SourcePostgresPostgresConnection.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 name: str,
                 database_name: Optional[str] = None,
                 schema_name: Optional[str] = None):
        """
        :param str name: The posgres_connection name.
        :param str database_name: The posgres_connection database name.
        :param str schema_name: The posgres_connection schema name.
        """
        pulumi.set(__self__, "name", name)
        if database_name is not None:
            pulumi.set(__self__, "database_name", database_name)
        if schema_name is not None:
            pulumi.set(__self__, "schema_name", schema_name)

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        The posgres_connection name.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter(name="databaseName")
    def database_name(self) -> Optional[str]:
        """
        The posgres_connection database name.
        """
        return pulumi.get(self, "database_name")

    @property
    @pulumi.getter(name="schemaName")
    def schema_name(self) -> Optional[str]:
        """
        The posgres_connection schema name.
        """
        return pulumi.get(self, "schema_name")


@pulumi.output_type
class SourcePostgresTable(dict):
    def __init__(__self__, *,
                 name: str,
                 alias: Optional[str] = None):
        """
        :param str name: The name of the table.
        :param str alias: The alias of the table.
        """
        pulumi.set(__self__, "name", name)
        if alias is not None:
            pulumi.set(__self__, "alias", alias)

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        The name of the table.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def alias(self) -> Optional[str]:
        """
        The alias of the table.
        """
        return pulumi.get(self, "alias")


@pulumi.output_type
class TableColumn(dict):
    def __init__(__self__, *,
                 name: str,
                 type: str,
                 nullable: Optional[bool] = None):
        """
        :param str name: The name of the column to be created in the table.
        :param str type: The data type of the column indicated by name.
        :param bool nullable: Do not allow the column to contain NULL values. Columns without this constraint can contain NULL values.
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "type", type)
        if nullable is not None:
            pulumi.set(__self__, "nullable", nullable)

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        The name of the column to be created in the table.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def type(self) -> str:
        """
        The data type of the column indicated by name.
        """
        return pulumi.get(self, "type")

    @property
    @pulumi.getter
    def nullable(self) -> Optional[bool]:
        """
        Do not allow the column to contain NULL values. Columns without this constraint can contain NULL values.
        """
        return pulumi.get(self, "nullable")


